%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[Scale=0.9,
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




    % 依赖包
    \usepackage{fontspec}   % 字体操作依赖包    
    \usepackage{xeCJK}      % 中文字体，特殊字体包
    \usepackage{graphicx}   % 画图包
    \usepackage{tikz}
    \usepackage{xcolor}
    \usepackage{geometry}  

    \setmainfont{Carlito}   % 设定主字体    
    \setCJKmainfont{AR PL UMing CN}
    \setCJKsansfont{AR PL UMing CN}
    \setCJKmonofont{AR PL UMing CN}
        
    \geometry{a4paper, left=2cm, right=2cm, top=2cm, bottom=2cm}
    
    \setcounter{secnumdepth}{0}  % 关闭自动章节编号
    \setcounter{tocdepth}{2}     % 目录层级
    \renewcommand{\thechapter}{}

    % 定义封面所需的命令（如果您的文档类需要）
    \makeatletter
    \newcommand{\customtitle}{\@title}
    \newcommand{\customauthor}{\@author}
    \newcommand{\customdate}{\@date}
    \makeatother
    

\title{FETMX6ULL-C OKMX6ULL-C}
\date{Aug 29, 2025}
\release{}
\author{Application Note}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}


    \begin{titlepage}
    \thispagestyle{empty}
    
    \definecolor{forlinxblue}{RGB}{0, 102, 178} % 定义封面蓝条颜色
    \begin{tikzpicture}[remember picture, overlay]

      % --- 左侧窄条 (上半部)：用于竖排文字
      \fill[forlinxblue] 
        (current page.north west) rectangle ++(2cm, -0.32\paperheight);

      % --- 左侧宽条 (下半部)：作为装饰块
      \fill[forlinxblue] 
        (current page.south west) 
        rectangle ++(2cm, 0.58\paperheight);

      % --- 竖排文字：垂直居中于上窄条
      \node[
        white,
        rotate=270,
        font=\bfseries\huge,
        anchor=center
      ] 
      at ([xshift=1cm,yshift=-0.15\paperheight]current page.north west) 
      {\customauthor};

       % --- LOGO ---
      \node[anchor=north east] 
        at ([xshift=-2cm, yshift=-2cm]current page.north east) 
        {\includegraphics[width=6cm]{../../_static/logo.png}};

      % --- 产品型号/文档标题 ---
      \node[anchor=north west, font=\huge\bfseries]
        at ([yshift=-10.5cm, xshift=2.1cm]current page.north west) 
        {\customtitle};

      % --- 子标题 ---
      \node[anchor=north west, font=\large]
        at ([yshift=-11.5cm, xshift=2.1cm]current page.north west)
        {Embedded Development Platform};

      % --- 文档类型 ---
      \node[anchor=north east, font=\LARGE\bfseries]
        at ([yshift=-15cm, xshift=-2cm]current page.north east)
        {\customauthor};

      % --- 版本号 ---
      \node[anchor=north east, font=\normalsize]
        at ([yshift=-16cm, xshift=-2cm]current page.north east)
        {Rev. 1.1};

      % --- 公司信息 左对齐 + 右对齐 ---
      \node[anchor=south west, font=\normalsize]
        at ([xshift=3cm, yshift=2cm]current page.south west)
        {Forlinx Embedded Technology Co. Ltd.};

      \node[anchor=south east, font=\normalsize]
        at ([xshift=-2cm, yshift=2cm]current page.south east)
        {www.forlinx.net};

    \end{tikzpicture}
    \end{titlepage}
    
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{linux-manual::doc}}



\chapter{1. Development Board Description你好aaaa3333f}
\label{\detokenize{linux-manual:development-board-descriptionaaaa3333f}}

\section{1.1 OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC Development Board Description}
\label{\detokenize{linux-manual:ok-mx8mpq-smarc-development-board-description}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board uses a SoM + carrier board architecture, designed based on the NXP i.MX 8M Plus industrial\sphinxhyphen{}grade processor. It features a quad\sphinxhyphen{}core Arm® Cortex®\sphinxhyphen{}A53 CPU with an integrated Neural Processing Unit (NPU) delivering up to 2.3 TOPS of performance and a maximum CPU frequency of 1.6GHz. Supports real\sphinxhyphen{}time control via Cortex\sphinxhyphen{}M7. Features a powerful control network with CAN FD and dual Gigabit Ethernet, supporting Time\sphinxhyphen{}Sensitive Networking (TSN).\\
The SoM comes in two options: 2GB LPDDR4 with 16GB eMMC, and 4GB LPDDR4 with 32GB eMMC. OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board is rich in interface resources, providing a variety of peripheral interfaces, such as NIC, audio Codec, ADC, TF Card, LVDS, MIPI, WIFI, 4G, 5G, PCIE, serial port, CAN and other functional interfaces.

\sphinxAtStartPar
\sphinxincludegraphics{{a9804aee43214dd0b33e88968e4896ce}.png}

\sphinxAtStartPar
\sphinxstylestrong{Note：}

\sphinxAtStartPar
\sphinxstylestrong{This software manual does not cover hardware specifications. Before using it for software development, please read the hardware manual in the “02\sphinxhyphen{}User Documents\textbackslash{}03\sphinxhyphen{}Hardware Documents\textbackslash{}02\sphinxhyphen{}Manual\textbackslash{}” directory to understand the product naming rules and hardware configuration. This will help you better use the product.}


\section{1.2 Introduction to Linux 6.1.36 System Software Resources}
\label{\detokenize{linux-manual:introduction-to-linux-6-1-36-system-software-resources}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Device
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Location of driver source code in the kernel
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Device Name
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
NIC Driver
&
\sphinxAtStartPar
drivers/net/ethernet/freescale/fec\_main.c
&
\sphinxAtStartPar
/sys/class/net/eth0
\\
\sphinxhline
\sphinxAtStartPar
Supports TSN (Time\sphinxhyphen{}Sensitive Networking).
&
\sphinxAtStartPar
drivers/net/ethernet/stmicro/stmmac/dwmac\sphinxhyphen{}imx.c
&
\sphinxAtStartPar
/sys/class/net/eth1
\\
\sphinxhline
\sphinxAtStartPar
LCD Backlight Driver
&
\sphinxAtStartPar
drivers/video/backlight/pwm\_bl.c
&
\sphinxAtStartPar
/sys/class/backlight/
\\
\sphinxhline
\sphinxAtStartPar
LED Driver
&
\sphinxAtStartPar
drivers/leds/leds\sphinxhyphen{}gpio.c
&
\sphinxAtStartPar
/sys/class/leds/
\\
\sphinxhline
\sphinxAtStartPar
USB
&
\sphinxAtStartPar
drivers/usb/dwc3/
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
4/5G
&
\sphinxAtStartPar
drivers/net/usb/gobi\_net
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
TF Driver
&
\sphinxAtStartPar
drivers/mmc/host/sdhci\sphinxhyphen{}esdhc\sphinxhyphen{}imx.c
&
\sphinxAtStartPar
/dev/block/mmcblk1pX
\\
\sphinxhline
\sphinxAtStartPar
serial port driver
&
\sphinxAtStartPar
drivers/tty/serial/imx.c
&
\sphinxAtStartPar
/dev/ttymxc
\\
\sphinxhline
\sphinxAtStartPar
watchdog driver
&
\sphinxAtStartPar
drivers/watchdog/imx2\_wdt.c
&
\sphinxAtStartPar
/dev/watchdog
\\
\sphinxhline
\sphinxAtStartPar
WIFI
&
\sphinxAtStartPar
drivers/net/wireless/nxp
&
\sphinxAtStartPar
mlan0
\\
\sphinxhline
\sphinxAtStartPar
Audio Driver
&
\sphinxAtStartPar
sound/soc/codecs/nau8822.c
&
\sphinxAtStartPar
/dev/snd/
\\
\sphinxhline
\sphinxAtStartPar
ecspi
&
\sphinxAtStartPar
drivers/spi/spi\sphinxhyphen{}imx.c
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
Flexspi
&
\sphinxAtStartPar
drivers/spi/spi\sphinxhyphen{}nxp\sphinxhyphen{}fspi.c
&
\sphinxAtStartPar

\\
\sphinxhline
\sphinxAtStartPar
I2C driver
&
\sphinxAtStartPar
drivers/i2c/busses/i2c\sphinxhyphen{}imx.c
&
\sphinxAtStartPar
/dev/i2c
\\
\sphinxhline
\sphinxAtStartPar
PWM Driver
&
\sphinxAtStartPar
drivers/pwm/pwm\sphinxhyphen{}imx27.c
&
\sphinxAtStartPar
/sys/class/pwm/
\\
\sphinxhline
\sphinxAtStartPar
GT928 Touch Driver
&
\sphinxAtStartPar
drivers/input/touchscreen/goodix.c
&
\sphinxAtStartPar
/dev/input/event
\\
\sphinxhline
\sphinxAtStartPar
ft5x06 Touch Driver
&
\sphinxAtStartPar
drivers/input/touchscreen/edt\sphinxhyphen{}ft5x06.c
&
\sphinxAtStartPar
/dev/input/event
\\
\sphinxhline
\sphinxAtStartPar
RTC Driver
&
\sphinxAtStartPar
drivers/rtc/rtc\sphinxhyphen{}pcf8563.c
&
\sphinxAtStartPar
/dev/rtc0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{1.3 Flashing and Boot Settings}
\label{\detokenize{linux-manual:flashing-and-boot-settings}}
\sphinxAtStartPar
It supports OTG programming and can boot U\sphinxhyphen{}Boot from eMMC, TF card, QSPI Flash (Module SPI), and SPI Flash (Carrier SPI).\\
The startup dial\sphinxhyphen{}up code is as follows:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{BOOT}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{4}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{3}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{2}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{1}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Carrier SD Card
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
\sphinxstylestrong{ON}
&
\sphinxAtStartPar
\sphinxstylestrong{ON}
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
Carrier SPI (CS0\#)
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
\sphinxstylestrong{ON}
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
Module eMMC Flash
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
\sphinxstylestrong{ON}
\\
\sphinxhline
\sphinxAtStartPar
Module SPI
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
&
\sphinxAtStartPar
OFF
\\
\sphinxhline
\sphinxAtStartPar
USB Serial Download
&
\sphinxAtStartPar
\sphinxstylestrong{ON}
&
\sphinxAtStartPar
X
&
\sphinxAtStartPar
X
&
\sphinxAtStartPar
X
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Please refer to the “System Flashing” section for specific flashing procedures.


\chapter{2. Fast Startup}
\label{\detokenize{linux-manual:fast-startup}}

\section{2.1 Preparation Before Startup}
\label{\detokenize{linux-manual:preparation-before-startup}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board has two system login methods, serial and network login.

\sphinxAtStartPar
Hardware preparation before system startup:
\begin{itemize}
\item {} 
\sphinxAtStartPar
12V3A DC Power Cable;

\item {} 
\sphinxAtStartPar
Debugging serial port cable (used for serial login): The debugging serial port USB Type\sphinxhyphen{}C port on the development board allows you to connect the development board and PC using a Type\sphinxhyphen{}A to Type\sphinxhyphen{}C cable to view the status information of the development board;

\item {} 
\sphinxAtStartPar
Network cable (for network login);

\item {} 
\sphinxAtStartPar
According to the development board interface to connect the screen (Based on display needs);

\item {} 
\sphinxAtStartPar
Check the start mode DIP switch. Please check the DIP switch on your development board and make sure it is set to the desired boot mode. Please refer to the startup mode settings.“Flashing and Startup Configuration”

\end{itemize}

\sphinxAtStartPar
\sphinxincludegraphics{{56f0b93ed9b14635a2493d58a2625d36}.png}


\section{2.2 Serial Login}
\label{\detokenize{linux-manual:serial-login}}

\subsection{2.2.1 Serial Login}
\label{\detokenize{linux-manual:id1}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Serial port settings: baud rate 115200, data bit 8, stop bit 1, no parity bit, no flow control;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Serial terminal login as root user, no password, login without account};

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Software: Windows PC requires Super Terminal; choose a familiar serial terminal software.}

\end{itemize}

\sphinxAtStartPar
Here is an example using Putty to explain how to configure the terminal:\\
\sphinxstylestrong{Step 1:} Connect the development board and the PC using a serial cable, and verify the serial port number recognized by the computer through the “Device Manager”. The port number recognized by the computer should be considered as the accurate one;\\
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Two serial ports will be generated, and SERIAL\sphinxhyphen{}B is the debugging serial port on the Linux side.\sphinxincludegraphics{{f74afcf5864f4206beb4f7fd381a03a9}.png}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Step 2:} Open and configure PuTTY; set the serial line to match the COM port of your computer with a baud rate of 115200.\sphinxincludegraphics{{b20d8743bdab4355b9bed0f8f57c72ca}.png}\\
\sphinxincludegraphics{{ee413bb0c9bb4bac98a0b37dd328d753}.png}

\sphinxAtStartPar
\sphinxstylestrong{Step 3:} Turn on the power switch of the development board, and serial port print information will be output until “Welcome to forlinx ok\sphinxhyphen{}mx8mpq\sphinxhyphen{}smarc” appears, indicating that the boot process is complete. The system defaults to the root account with no password, so you do not need to enter any login information.


\subsection{2.2.2 Serial Login Common Problems}
\label{\detokenize{linux-manual:serial-login-common-problems}}
\sphinxAtStartPar
Common problem troubleshooting points for logging in using the serial port are as follows:

\sphinxAtStartPar
\sphinxstylestrong{Case 1:} No information is printed after the serial port is connected:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
First, check whether the DIP switch is correct;

\item {} 
\sphinxAtStartPar
Re\sphinxhyphen{}open the serial port;

\item {} 
\sphinxAtStartPar
Change a serial port cable to test it;

\item {} 
\sphinxAtStartPar
If all of the above still does not work, check the status of the SoM’s LED, if it is not a heartbeat light or does not light up, suspect that the system does not start normally, you need to check the system startup, or rewrite it!

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Case 2:} Command cannot be input after serial port is connected:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Re\sphinxhyphen{}open the serial port;

\item {} 
\sphinxAtStartPar
Replace the USB serial port cable with a new USB port on the computer, view the corresponding COM port in the device management, and reopen the serial port;

\item {} 
\sphinxAtStartPar
Replace a serial port cable.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Case 3:} The port was not recognised by Device Manager:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Serial port driver is not installed. Try to install serial port driver.

\end{enumerate}


\section{2.3 Network Login Methods}
\label{\detokenize{linux-manual:network-login-methods}}

\subsection{2.3.1 Network Connection Test}
\label{\detokenize{linux-manual:network-connection-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The default factory IP of eth0 is 192.168. 0. 232 (carrier board GBE1 network port);}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The computer and board should be on the same network segment for testing.}

\end{itemize}

\sphinxAtStartPar
Before login, ensure the network connection between the computer and the development board is normal, and use the ping command to test the connection status. The specific method of operation is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Connect the development board’s GBE1 port to the computer using an Ethernet cable. Power on the board and boot the kernel. Confirm the blue heartbeat LED is blinking. Check the network card connection, ensuring its LED flashes rapidly. Once confirmed, proceed with testing the network connection.\sphinxincludegraphics{{4cd7a79e2c504f43a042671339689520}.png}

\end{enumerate}

\sphinxAtStartPar
2. Close the computer firewall (General computer operations, not described here in detail), then open the computer’s run command.

\sphinxAtStartPar
\sphinxstylestrong{\sphinxincludegraphics{{0ddb4a6af9e74c2da69a786786ff152d}.png}}

\sphinxAtStartPar
3. Use cmd to open the computer administrator interface, and use the ping command to test the network connection status of the computer and the development board.

\sphinxAtStartPar
\sphinxincludegraphics{{c52686a86ab84f85a682a667b78cb6b9}.png}

\sphinxAtStartPar
The data is returned, and the network connection is normal.


\subsection{2.3.2 SSH server}
\label{\detokenize{linux-manual:ssh-server}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Default factory account root for SSH login with no password;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The default factory IP for eth0 (carrier board GBE1) is 192.168.0.232, and eth1 (carrier board GBE0) uses DHCP to obtain the IP;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{File transfers can be performed with scp or sftp.}\\
Plug the Ethernet cable into the GBE0 port on the carrier board to obtain the eth1 IP address.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ifconfig
eth0: flags=4099\PYGZlt{}UP,BROADCAST,MULTICAST\PYGZgt{}  mtu 1500
        ether ae:ae:f7:61:20:20  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1: flags=4163\PYGZlt{}UP,BROADCAST,RUNNING,MULTICAST\PYGZgt{}  mtu 1500
        inet 192.168.1.3  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 2408:8207:78d0:9310:acae:f7ff:fe61:201f  prefixlen 64  scopeid 0x0\PYGZlt{}global\PYGZgt{}
        inet6 fe80::acae:f7ff:fe61:201f  prefixlen 64  scopeid 0x20\PYGZlt{}link\PYGZgt{}
        ether ae:ae:f7:61:20:1f  txqueuelen 1000  (Ethernet)
        RX packets 6217  bytes 1241331 (1.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 247  bytes 25763 (25.1 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 227

lo: flags=73\PYGZlt{}UP,LOOPBACK,RUNNING\PYGZgt{}  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10\PYGZlt{}host\PYGZgt{}
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 323  bytes 461862 (451.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 323  bytes 461862 (451.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{ddad511fe1494f42aa03345de6fa1fff}.png}

\sphinxAtStartPar
Click “Open”, the following dialog box will appear, click “accept” to enter the login interface.

\sphinxAtStartPar
\sphinxincludegraphics{{572eadcc10da4bd6bdaf42f62baae62a}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
login as: root
Last login: Sat Mar  4 16:21:40 2023  //root without password
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Files can be copied via SFTP using FileZilla (software must be installed by yourself).

\sphinxAtStartPar
\sphinxincludegraphics{{7fe8ae0d719c45bcbb45ade6f17e608c}.png}


\section{2.4 System Partition}
\label{\detokenize{linux-manual:system-partition}}

\subsection{2.4.1 eMMC Version}
\label{\detokenize{linux-manual:emmc-version}}
\sphinxAtStartPar
The following table is the eMMC memory partition information of Linux operating system:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Device Nodes}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Initial Address}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Size}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Partition}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{File system}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Content}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
mmcblk2boot0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
4MB
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
Uboot Image
\\
\sphinxhline
\sphinxAtStartPar
mmcblk2
&
\sphinxAtStartPar
0x700000
&
\sphinxAtStartPar
0x4000
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
Uboot environment variable
\\
\sphinxhline
\sphinxAtStartPar
mmcblk2
&
\sphinxAtStartPar
0x800000
&
\sphinxAtStartPar
120MB
&
\sphinxAtStartPar
mmcblk2p1
&
\sphinxAtStartPar
Vfat
&
\sphinxAtStartPar
Kernel image and device tree, etc
\\
\sphinxhline
\sphinxAtStartPar
mmcblk2
&
\sphinxAtStartPar
0x8000000
&
\sphinxAtStartPar
Full eMMC capacity remaining
&
\sphinxAtStartPar
mmcblk2p2
&
\sphinxAtStartPar
Ext4
&
\sphinxAtStartPar
root file system
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Use the df command to view disk usage on a system. The following image shows the default disk usage at factory settings (eMMC size: 16GB with a QT file system). This is for reference only; actual parameters may vary.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} df \PYGZhy{}Th
Filesystem     Type      Size  Used Avail Use\PYGZpc{} Mounted on
/dev/root      ext4       14G  6.9G  6.0G  54\PYGZpc{} /
devtmpfs       devtmpfs  589M  4.0K  589M   1\PYGZpc{} /dev
tmpfs          tmpfs     831M  5.9M  825M   1\PYGZpc{} /dev/shm
tmpfs          tmpfs     333M  9.3M  323M   3\PYGZpc{} /run
tmpfs          tmpfs     4.0M     0  4.0M   0\PYGZpc{} /sys/fs/cgroup
tmpfs          tmpfs     831M  112K  831M   1\PYGZpc{} /tmp
tmpfs          tmpfs     831M  308K  830M   1\PYGZpc{} /var/volatile
/dev/mmcblk2p1 vfat      120M   36M   84M  31\PYGZpc{} /run/media/Boot\PYGZhy{}mmcblk2p1
tmpfs          tmpfs     167M  4.0K  167M   1\PYGZpc{} /run/user/0
\end{sphinxVerbatim}

\sphinxAtStartPar
Use the free command to check memory usage. As shown in the figure below, this is the memory usage without any external devices connected (DDR size is 2GB). This is for reference only; please refer to actual parameters for precise information.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} free \PYGZhy{}m
               total        used        free      shared  buff/cache   available
Mem:            1660         366        1063          24         343        1293
Swap:              0           0           0
\end{sphinxVerbatim}


\section{2.5 System Shutdown}
\label{\detokenize{linux-manual:system-shutdown}}
\sphinxAtStartPar
In general, the power can be turned off directly, if there is data storage, function use and other operations, do not arbitrarily disconnect the power during the operation, in order to prevent irreversible damage to the file, you can only re\sphinxhyphen{}burn the firmware. To ensure the data is completely written, enter the sync command to synchronize the data before turning off the power.\\
The command ‘reboot’ can be used to restart the development board. You can also restart the hardware by pressing the RESET key or directly power off and restart.\\
Note: If the product designed by the user based on the core board has an abnormal system shutdown due to an accidental power loss in use, measures such as power\sphinxhyphen{}down protection can be incorporated into the design.


\chapter{3. Platform Interface Function Use and Test}
\label{\detokenize{linux-manual:platform-interface-function-use-and-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Users should follow this section when using the screen with the QT file system, but can skip it for non\sphinxhyphen{} QT operations;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{This chapter focuses on describing the functionalities in Qt. It is assumed that the default device is connected properly and the drivers are loaded correctly during testing. It is recommended to test the command line functionalities before testing the interface functionalities;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{QT test program source code path:okmx8mp\sphinxhyphen{}smarc\sphinxhyphen{}appsrc.tar.zst};

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Path to the test program in the development board file system: /usr/bin/fltest\_qt\_*}.

\end{itemize}

\sphinxAtStartPar
This chapter mainly explains the usage of the expansion interfaces on the development board in QT interface. The testing program is only for reference, and users need to make adjustments based on their actual situations when using it.


\section{3.1 Introduction to Interface Function}
\label{\detokenize{linux-manual:introduction-to-interface-function}}
\sphinxAtStartPar
The desktop is displayed as follows after the board is booted:\sphinxincludegraphics{{fca276e19857485ea823ac2240733228}.png}\\
\sphinxincludegraphics{{3fe290b781e24e7fa97a0a8790b0b7f5}.png}\sphinxstylestrong{Note: Icon order may vary.}


\section{3.2 Network Configuration Test}
\label{\detokenize{linux-manual:network-configuration-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{By default, only the eth0 network interface (GBE1 port on the carrier board) is set to STATIC mode;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The set IP and other information will be saved to the relevant configuration file (/etc/systemd/network directory) of the system, so the network information set this time will be used every time the system is restarted.}

\sphinxAtStartPar
Icon\sphinxincludegraphics{{e379b39da7af498591c0269c708f2e64}.png}

\sphinxAtStartPar
Clicking on the network configuration icon will open a interface program that supports two modes: STATIC and DHCP.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{STATIC Mode}

\sphinxAtStartPar
After clicking on the network configuration icon, select the STATIC mode as shown in the figure. You can then configure the IP address, subnet mask, gateway, and DNS settings. Once you have set the parameters, click on “Apply and Restart Network”.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Relevant Parameter}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Meaning}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
interface
&
\sphinxAtStartPar
0 Set up the network card
\\
\sphinxhline
\sphinxAtStartPar
ip
&
\sphinxAtStartPar
Set the IP address
\\
\sphinxhline
\sphinxAtStartPar
netmask
&
\sphinxAtStartPar
Set the subnet mask
\\
\sphinxhline
\sphinxAtStartPar
gateway
&
\sphinxAtStartPar
Set up the gateway
\\
\sphinxhline
\sphinxAtStartPar
dns
&
\sphinxAtStartPar
Set DNS
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxincludegraphics{{4dd6869cddaf40d4a3705c0e49a53dec}.png}

\sphinxAtStartPar
The DHCP mode interface is as follows:\\
\sphinxstylestrong{Note: The test must be conducted under a router that can automatically assign IP addresses.}

\sphinxAtStartPar
Select DHCP, then choose the network card device to be configured in the “interface”. Click “Apply and Restart Network” at the bottom of the interface, and the network will automatically restart and an IP address will be automatically obtained.\\
\sphinxincludegraphics{{53c9ce5ef90c4489aaa02ad4349714d5}.png}Restart the development board, and you can see that the network configuration is in effect.\\
\sphinxstylestrong{Note: If you configure eth0 with a static IP and eth1 with a dynamic IP simultaneously, it may cause routing abnormalities. If you encounter network connectivity issues, it is recommended to check the routing table. It is recommended to configure only one network port at a time.}


\section{3.3 OpenGL Test}
\label{\detokenize{linux-manual:opengl-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{66713b0eb0d343a198dfcfc18082b674}.png}\\
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports EGL 1.5，OpenGL ES2.0.\\
Click the icon to enter the OpenGL test interface.\sphinxincludegraphics{{b08b70fb18954c80b3011c9ade6df31f}.png}


\section{3.4 4G/5G Test}
\label{\detokenize{linux-manual:g-5g-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{c302b37888bc466b93657f9cb0416cea}.png}\\
“4G” test program is used to test the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC external 4G module (EM05\sphinxhyphen{}CE), 5G module (RM500U\sphinxhyphen{}CN, RM500Q\sphinxhyphen{}GL). Before the test, please power off the development board, connect the module, insert the SIM card (pay attention to the direction of the SIM card), toggle the switch (S4) to select the 4G, 5G mode, and start the development board to open the test application. This test takes 4G as an example:\\
\sphinxincludegraphics{{bf6d23106c734d989d656caf36b1eb84}.png}\\
\sphinxincludegraphics{{1d8815feb87144f8987b180399645410}.png}Click the “connect” button, the program will automatically enter the dial\sphinxhyphen{}up process and get the IP settings DNS, etc., wait a few seconds, and click the ping button to test.


\section{3.5 UART Test}
\label{\detokenize{linux-manual:uart-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{0ca48fd94c5a4d6797b2ebe24e630caf}.png}\\
In this test, the carrier board uart3 (ttymxc0) and the carrier board USB to UART (/dev/ttyCH343USB) are used, and the pins 1 and 2 of the pin header of the development board P27 are short\sphinxhyphen{}circuited with pins 4 and 5 respectively to conduct the serial port test.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Click the UART test icon to enter the test application interface, click the gear icon\sphinxincludegraphics{{59930d73d0c14871b257e506207cd55f}.png}setting button in the upper left corner, and set the serial port parameters as shown in the figure below:

\end{enumerate}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Relevant Parameter}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Meaning}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Select Serial Port
&
\sphinxAtStartPar
Set the serial port (select ttymxc0)
\\
\sphinxhline
\sphinxAtStartPar
BaudRate
&
\sphinxAtStartPar
Set baud rate (115200)
\\
\sphinxhline
\sphinxAtStartPar
Data bits
&
\sphinxAtStartPar
Set data bits (8 bits)
\\
\sphinxhline
\sphinxAtStartPar
Parity
&
\sphinxAtStartPar
Set parity bit (no parity)
\\
\sphinxhline
\sphinxAtStartPar
Stop bits
&
\sphinxAtStartPar
Set stop bit (1 bit)
\\
\sphinxhline
\sphinxAtStartPar
Flow control
&
\sphinxAtStartPar
Set flow control (no flow control)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxincludegraphics{{ad247d08c1ae4b3d9693c663792115f9}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
After setting the serial port parameters, click the\sphinxincludegraphics{{4a237fb1ca8e42bf88561596781a58b2}.png}connection button in the upper left corner. At this time, the test program can carry out the data receiving and sending test.

\item {} 
\sphinxAtStartPar
Run the serial port send test command in the terminal. The received data will be displayed on the screen.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}uarttest \PYGZhy{}d /dev/ttyCH343USB  \PYGZhy{}w 
tx\PYGZus{}0: XEiNKcpIXrzQF4t9PqirDCTqWKgLnKoK
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{041d20cb846f40d2826c8865d1b3224e}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Run the serial port receive test command in the terminal. When you click the test interface, a virtual keyboard will appear. After entering 32 consecutive characters, the terminal will print the data sent by QT.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}uarttest \PYGZhy{}d /dev/ttyCH343USB  \PYGZhy{}r
rx\PYGZus{}0: 12345678901234567890123456789012
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{2e18d1c3af614ea4b15ff01ab6ea9c3f}.png}\sphinxstylestrong{Note: The data input by the soft keyboard will not be displayed on the test interface until the Enter key is pressed.}


\section{3.6 WIFI Test}
\label{\detokenize{linux-manual:wifi-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC SoM is soldered with the AW\sphinxhyphen{}CM276 NF WiFi chip and supports 2.4 GHz/5 GHz.}

\end{itemize}

\sphinxAtStartPar
“WIFI” is a tool for configuring and testing the STA (station) mode of Wi\sphinxhyphen{}Fi.\\
1. Click on the icon\sphinxincludegraphics{{742cb59ecc034487862cf4fc45e28e47}.png}to enter the test interface. From the dropdown menu, select the corresponding module. In the SSID, input the name of the router you want to connect. In the PAWD, input the router’s password. Then, click “connect” to establish a WiFi connection with the router.\\
\sphinxincludegraphics{{7457f862f32c4cafa22bf848f223403a}.png}2. “Click” ping to test the network after a successful connection.\sphinxincludegraphics{{a92b68218fd644e8a6aa8ac8e7835bca}.png}


\section{3.7 RTC Test}
\label{\detokenize{linux-manual:rtc-test}}
\sphinxAtStartPar
\sphinxstylestrong{Note: Ensure that button cell batteries are installed on the board and the battery voltage is normal.}

\sphinxAtStartPar
Icon：\sphinxincludegraphics{{7be334d098f242b9898431e794dd0783}.png}\\
RTC test includes setting time, power cycling, rerunning test software, and verifying RTC sync.\\
Run the RTC test software to view and set the current system time with the following interface:\\
\sphinxincludegraphics{{c3471066d6174a94a3f3ad733c707bc2}.png}After SET, users can set the time and click Save to finish the settings. After powering off and waiting, reboot and rerun the RTC test software to synchronize and confirm the RTC test is normal.


\section{3.8 Watchdog Test}
\label{\detokenize{linux-manual:watchdog-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{8f7452581d4449eba74adcdca46891d1}.png}\\
“WatchDog” tests the functionality of the watchdog feature. Interface as follows:\\
\sphinxincludegraphics{{2ca60485c1ee426abf97af970461bd8d}.png}Check ” feed dog and click the open watchdog key, then the watchdog will be activated, the program will carry out the feeding operation, and the system will not reboot under normal circumstances; when unchecking ” feed dog and clicking open watchdog key, the watchdog function will be activated, the program will not carry out the feeding operation, and the system enters into a reboot after the watchdog is activated for about 10s, which indicates that the watchdog function is normal.


\section{3.9 Ping Test}
\label{\detokenize{linux-manual:ping-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{8f4272babe6e4561b56cd71515c91f5a}.png}\\
“Ping” is a graphical tool for network testing, offering a user\sphinxhyphen{}friendly interface for ping operations.\\
\sphinxincludegraphics{{6cd5805bca584d97b3924104ae32c991}.png}Write the target ip needing ping in the hostname field;  after clicking the ping button, the RESULT column will indicate the result, click stop to end the ping test and clear to clean the information in the result.\\
As shown in the figure, the network connection is smooth.\sphinxincludegraphics{{5795aa925d9848d1b4eb0bf0ee27f2ea}.png}


\section{3.10 Camera Test}
\label{\detokenize{linux-manual:camera-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{9d10749908254e669faff8fb5c0eabca}.png}\\
Click the icon to enter the camera test program and insert the USB camera.\\
\sphinxstylestrong{Note: if the CSI ov5645 camera is used, please disconnect the power and plug it; the current test program does not support basler \_ camera.}\\
\sphinxincludegraphics{{85bc01f11d844f52ace7ed9bcb0a22d3}.png}\\
Please select camera video to set the device node, camera resolution to set the resolution, click the start button to start camera acquisition, click the stop button to stop camera acquisition, click the picture button to take a picture, and save the path and file name of the picture.\\
Take the Logitech UVC camera as an example to conduct the camera test.\\
\sphinxincludegraphics{{25b71fb1d213427e8e61482213a745c4}.png}After Start, click the picture button to take a picture, the file save directory is /home/root/, and the format is jpg, please select the appropriate tool on Windows to view.


\section{3.11 Backlight Test}
\label{\detokenize{linux-manual:backlight-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{2bfb421a89ee427cbe3201fdd16db27f}.png}\\
“BackLight” is an LCD backlight adjustment App with a left\sphinxhyphen{}right progress bar for brightness control. Click to open the interface as follows:\\
\sphinxincludegraphics{{5fea84effaf049d68df3c8588579c537}.png}Drag the slider corresponding to the screen in the interface to set the Lcd backlight brightness, level 1 is the lowest brightness, and 255 is the highest brightness. Forlinx has made restrictions on this application. It is not allowed to use the QT application to completely turn off the backlight. If you want to completely turn off the backlight, please use the command line program or modify the QT test routine.


\section{3.12 Play/Record Test}
\label{\detokenize{linux-manual:play-record-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{6db02299ab7542e8a584562c43e5e54c}.png}\\
Before conducting the audio recording test, please insert the prepared microphone into the mic port. Click the icon to enter the recording test application, which can be used to check if the sound card recording function is working properly.\\
Select the location to save the recording file, press the “Start” button to start recording, press the “Stop” button to stop recording, click the Audio Codec radio box to select “Wave”, click the FILE Container radio box to select “Wave File”, click the Channels radio box to select 2, and the interface is as follows:\\
\sphinxincludegraphics{{cd5162461b5045689677082f51b43b32}.png}Click the Record button to test the recording. The recording file is saved to the/tmp/record \_ *.wav file in the root directory.\\
Note: The/TMP directory is tmpfs and the files in it are not saved after reboot.


\section{3.13 Music Play Test}
\label{\detokenize{linux-manual:music-play-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{b34e77692264471988527cb2e87c698f}.png}\\
“music player” is a simple audio test application that can be used to test the function of the sound card or as a simple audio player.\\
\sphinxincludegraphics{{cfafef1663614d7bbffc52da985b7274}.png}\\
Application interface

\sphinxAtStartPar
Click the button in the lower left corner and select Test Audio/home/forlinx/audio/test.mp3.

\sphinxAtStartPar
Please note the audio device during playback, which is HDMI by default.


\section{3.14 Qml Video Playback Test}
\label{\detokenize{linux-manual:qml-video-playback-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{7774e619f1ce44648ec60323aabdd162}.png}\\
Qml Video supports video playback in H264 and H265 formats, with a maximum of 1080p 60fps.\\
The qml video test program can play video based on qml. Click the icon to enter the test program interface.\\
\sphinxincludegraphics{{c488930e0a724fae94b5dc493fde735b}.png}Click Select File 1 at the top to select the video file. The path of the test video file is shown in the following figure:\\
\sphinxincludegraphics{{035e42ac7f5647ad9c9e4783e465c0a9}.png}Click Full Screen\sphinxhyphen{}inverted to start playing the video in full screen.\sphinxincludegraphics{{b463fb70f7a043b18153f78481d28cb3}.png}


\section{3.15 Browser Test}
\label{\detokenize{linux-manual:browser-test}}
\sphinxAtStartPar
Icon：\sphinxincludegraphics{{bf0c78842aaf42dfbf900dcbf0d61e97}.png}\\
\sphinxstylestrong{Note: Before testing, check whether the time of the development board is accurate. If the time of the development board is abnormal, it will cause certificate problems. Check the network.}\\
Click the icon to enter the browser interface and enter the official website of forlinx by default.\sphinxincludegraphics{{dc6bbab62dd9405f83aff56fb9446a90}.png}


\chapter{4. Command Line Tool Application and Test}
\label{\detokenize{linux-manual:command-line-tool-application-and-test}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform has a wealth of built\sphinxhyphen{}in command line tools and FORLINX test programs available to users.\\
FORLINX test program source code path：okmx8mp\sphinxhyphen{}smarc\sphinxhyphen{}appsrc.tar.zst\\
test program path：/usr/bin


\section{4.1 System Information Query}
\label{\detokenize{linux-manual:system-information-query}}
\sphinxAtStartPar
To view the kernel information, enter the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} uname \PYGZhy{}a
Linux ok\PYGZhy{}mx8mpq\PYGZhy{}smarc 6.1.36 \PYGZsh{}5 SMP PREEMPT Thu Mar 21 18:26:21 CST 2024 aarch64 GNU/Linux
\end{sphinxVerbatim}

\sphinxAtStartPar
To view CPU information:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /proc/cpuinfo
processor       : 0
BogoMIPS        : 16.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid
CPU implementer : 0x41
CPU architecture: 8
CPU variant     : 0x0
CPU part        : 0xd03
CPU revision    : 4

processor       : 1
BogoMIPS        : 16.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid
CPU implementer : 0x41
CPU architecture: 8
CPU variant     : 0x0
CPU part        : 0xd03
CPU revision    : 4

processor       : 2
BogoMIPS        : 16.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid
CPU implementer : 0x41
CPU architecture: 8
CPU variant     : 0x0
CPU part        : 0xd03
CPU revision    : 4

processor       : 3
BogoMIPS        : 16.00
Features        : fp asimd evtstrm aes pmull sha1 sha2 crc32 cpuid
CPU implementer : 0x41
CPU architecture: 8
CPU variant     : 0x0
CPU part        : 0xd03
CPU revision    : 4
\end{sphinxVerbatim}

\sphinxAtStartPar
View environment variable information:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} env
SHELL=/bin/sh
EDITOR=vi
QTWEBENGINE\PYGZus{}DISABLE\PYGZus{}SANDBOX=1
PWD=/home/root
LOGNAME=root
XDG\PYGZus{}SESSION\PYGZus{}TYPE=tty
MOTD\PYGZus{}SHOWN=pam
HOME=/home/root
LANG=en\PYGZus{}US.utf8
WAYLAND\PYGZus{}DISPLAY=/run/wayland\PYGZhy{}0
QT\PYGZus{}QPA\PYGZus{}PLATFORM=wayland
XDG\PYGZus{}SESSION\PYGZus{}CLASS=user
TERM=linux
USER=root
SHLVL=1
XDG\PYGZus{}SESSION\PYGZus{}ID=c2
XDG\PYGZus{}RUNTIME\PYGZus{}DIR=/run/user/0
PS1=\PYGZbs{}u@\PYGZbs{}h:\PYGZbs{}w\PYGZbs{}\PYGZdl{} 
LC\PYGZus{}ALL=en\PYGZus{}US.utf8
HUSHLOGIN=FALSE
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin
DBUS\PYGZus{}SESSION\PYGZus{}BUS\PYGZus{}ADDRESS=unix:path=/run/user/0/bus
MAIL=/var/spool/mail/root
\PYGZus{}=/usr/bin/env
\end{sphinxVerbatim}


\section{4.2 Frequency Test}
\label{\detokenize{linux-manual:frequency-test}}
\sphinxAtStartPar
\sphinxstylestrong{Note: This process changes all CPU cores at the same time.}\\
1. All cpufreq governor types supported in the current kernel:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat \PYGZbs{}
/sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}available\PYGZus{}governors
conservative ondemand userspace powersave performance schedutil
\end{sphinxVerbatim}

\sphinxAtStartPar
The default mode is ondemand. In this mode, the CPU frequency will be adjusted according to the demand. Check the current CPU freq governor type:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}governor
ondemand
\end{sphinxVerbatim}

\sphinxAtStartPar
To view the current frequency:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}cur\PYGZus{}freq
1200000
\end{sphinxVerbatim}

\sphinxAtStartPar
2. To view the frequency gears supported by the CPU:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat \PYGZbs{}
/sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}available\PYGZus{}frequencies
1200000 1600000
\end{sphinxVerbatim}

\sphinxAtStartPar
3. You can adjust the CPU frequency directly, setting governor to userspace

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo userspace \PYGZgt{} \PYGZbs{}
/sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}governor
\end{sphinxVerbatim}

\sphinxAtStartPar
Set frequency and view:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo 1600000 \PYGZgt{} \PYGZbs{}
/sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}setspeed
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/devices/system/cpu/cpufreq/policy0/scaling\PYGZus{}cur\PYGZus{}freq
1600000
\end{sphinxVerbatim}


\section{4.3 Temperature Test}
\label{\detokenize{linux-manual:temperature-test}}
\sphinxAtStartPar
View the temperature value:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/class/thermal/thermal\PYGZus{}zone0/temp
64000
\end{sphinxVerbatim}

\sphinxAtStartPar
The temperature value is 64°C.


\section{4.4 DDR Bandwidth Test:}
\label{\detokenize{linux-manual:ddr-bandwidth-test}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}memory\PYGZus{}bandwidth.sh
L1 cache bandwidth rd test with \PYGZsh{} process
0.008192 22223.96
0.008192 22476.32
0.008192 22313.32
0.008192 22485.39
0.008192 22367.47
L2 cache bandwidth rd test
0.131072 9715.20
0.131072 9754.08
0.131072 9699.33
0.131072 9713.46
0.131072 9705.50
Main mem bandwidth rd test
52.43 2865.59
52.43 2865.27
52.43 2853.42
52.43 2861.37
52.43 2862.46
L1 cache bandwidth wr test with \PYGZsh{} process
0.008192 19519.52
0.008192 19523.07
0.008192 19526.63
0.008192 19503.99
0.008192 19525.18
L2 cache bandwidth wr test
0.131072 10508.58
0.131072 11262.22
0.131072 11534.91
0.131072 11543.55
0.131072 11526.86
Main mem bandwidth wr test
52.43 1237.20
52.43 1235.22
52.43 1267.74
52.43 1255.57
52.43 1248.81
\end{sphinxVerbatim}

\sphinxAtStartPar
The lpDDR4 bandwidth of the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC is shown above, with a read bandwidth of about 2800M/s and a write bandwidth of about 1250M/s.


\section{4.5 Watchdog Test}
\label{\detokenize{linux-manual:id2}}
\sphinxAtStartPar
Watchdog is a frequently used function in embedded systems, and the device node for the watchdog in OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC is /dev/watchdog.\\
Use fltest\_watchdog to start the watchdog, set the reset time to 10s, and feed the dog regularly. This command will turn on the watchdog and perform the dog\sphinxhyphen{}feeding operation, so the system will not reboot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}watchdog \PYGZhy{}t10 \PYGZhy{}c
Watchdog Ticking Away!
\end{sphinxVerbatim}

\sphinxAtStartPar
When ctrl + C is used to end the test procedure, the dog feeding is stopped, the watchdog is in the open state, and the system is reset after 10s; If you do not want to reset, please enter the command to close the watchdog within 10 seconds after the end of the program:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}watchdog \PYGZhy{}d                      //Turn off the watchdog
\end{sphinxVerbatim}

\sphinxAtStartPar
Start the watchdog, set the reset time for 10s, and do not feed the dog. This command turns on the watchdog, but does not feed the dog, and the system restarts after 10 seconds.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}watchdog \PYGZhy{}t10 \PYGZhy{}e
\end{sphinxVerbatim}


\section{4.6 RTC Function Test}
\label{\detokenize{linux-manual:rtc-function-test}}
\sphinxAtStartPar
\sphinxstylestrong{Note: Ensure that button cell batteries are installed on the board and the battery voltage is normal.}\\
RTC test: The main way to set the software and hardware time is by using the date and hwclock utilities. When performing the board power\sphinxhyphen{}down and power\sphinxhyphen{}up test, the software clock reads whether the RTC clock is synchronized or not.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} date \PYGZhy{}s \PYGZdq{}2024\PYGZhy{}03\PYGZhy{}22 11:59:30\PYGZdq{}	           //Set the software time
Fri Mar 22 11:59:30 AM CST 2024
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} hwclock \PYGZhy{}w			           //Synchronize software time to hardware time
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} hwclock \PYGZhy{}r			                       //Display hardware time
2024\PYGZhy{}03\PYGZhy{}22 12:00:07.037836+08:00
\end{sphinxVerbatim}

\sphinxAtStartPar
Then power off and power on the development board, read the system time after entering the system, and you can see that the time has been synchronized.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} date
Fri Mar 22 12:01:22 PM CST 2024
\end{sphinxVerbatim}


\section{4.7 UART Test}
\label{\detokenize{linux-manual:id3}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board is equipped with 4 UART ports, which are labeled on the board as follows:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{UART}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Device Nodes}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Description}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
UART3
&
\sphinxAtStartPar
ttymxc0
&
\sphinxAtStartPar
RS485 level, can be used for this test.
\\
\sphinxhline
\sphinxAtStartPar
UART1
&
\sphinxAtStartPar
ttymxc1
&
\sphinxAtStartPar
The debug serial port cannot be used for this test.
\\
\sphinxhline
\sphinxAtStartPar
UART0
&
\sphinxAtStartPar
ttymxc2
&
\sphinxAtStartPar
The Bluetooth interface cannot be used for this test.
\\
\sphinxhline
\sphinxAtStartPar
UART2
&
\sphinxAtStartPar
ttymxc3
&
\sphinxAtStartPar
The debug serial port cannot be used for this test.
\\
\sphinxhline
\sphinxAtStartPar
CH343USB
&
\sphinxAtStartPar
ttyCH343USB
&
\sphinxAtStartPar
RS485 level, can be used for this test.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The maximum baud rate supported by 485 is 4000000, supports parity check, CS5, CS6, CS7, CS8, and 1bit and 2bit stop bits.\\
In this test, ttymxc0 and ttymxc2 are used to test the serial port by short\sphinxhyphen{}circuiting pins 1 and 4, pins 2 and 5, pins 3 and 6 of P27 respectively.

\sphinxAtStartPar
\sphinxincludegraphics{{177a3627aa8d486eadd18a41c8ca3dff}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}uarttest \PYGZhy{}d /dev/ttymxc0 \PYGZhy{}r \PYGZam{}
[2]1166
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}uarttest \PYGZhy{}d /dev/ttyCH343USB0 \PYGZhy{}w
tx\PYGZus{}0: wmfUOEUt097eLdSudH1ByJCY67DOP0DL
rx\PYGZus{}0: wmfUOEUt097eLdSudH1ByJCY67DOP0DL
[2]+  Done                    fltest\PYGZus{}uarttest \PYGZhy{}d /dev/ttymxc0 \PYGZhy{}r
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}


\section{4.8 PCIE}
\label{\detokenize{linux-manual:pcie}}
\sphinxAtStartPar
Before powering up the system, insert the PCIE module into the PCIE card slot on the carrier board. After powering on and starting Linux, you can see that the corresponding device is enumerated successfully through lspci. Taking the Intel 82574L NIC as an example, the successful enumeration is shown below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} lspci
00:00.0 PCI bridge: Synopsys, Inc. DWC\PYGZus{}usb3 / PCIe bridge (rev 01)
01:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
\end{sphinxVerbatim}

\sphinxAtStartPar
Due to the many types of pcie devices, it may not be supported by the kernel by default, so you need to add the corresponding driver for the compiled device by yourself.


\section{4.9 TF Test}
\label{\detokenize{linux-manual:tf-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The SD card mount directory is /run/media/ and supports hot\sphinxhyphen{}swapping;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{If the file system doesn’t support NTFS, format the TF card as FAT32 before use, especially if unsure of its current format.}

\item {} 
\sphinxAtStartPar
**After inserting the TF card, the device node is “/dev/mmcblk1 *”. **

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Insert the TF card into the TF card slot on the carrier board. The printed information is as follows:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[ 4075.276047] mmc1: host does not support reading read\PYGZhy{}only switch, assuming write\PYGZhy{}enable
[ 4075.311963] mmc1: new ultra high speed SDR104 SDHC card at address 5048
[ 4075.328510] mmcblk1: mmc1:5048 SD32G 29.7 GiB 
[ 4075.334519]  mmcblk1: p1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Check the mount directory:

\end{enumerate}

\sphinxAtStartPar
The TF card mount directory is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls /run/media/               //List files in the/run/media directory
boot\PYGZhy{}mmcblk1p1  Boot\PYGZhy{}mmcblk2p1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Write test:

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: Please ensure that there is enough space in the TF card partition before writing}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/zero of=/run/media/boot\PYGZhy{}mmcblk1p1/test.bin \PYGZbs{}
bs=1M count=200 conv=fsync oflag=direct
200+0 records in
200+0 records out
209715200 bytes (210 MB, 200 MiB) copied, 10.7905 s, 19.4 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Read test:

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: To make sure the data is accurate, please restart the development board and test the reading speed.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/run/media/boot\PYGZhy{}mmcblk1p1/test.bin of=/dev/null \PYGZbs{}
bs=1M count=200 iflag=direct
200+0 records in
200+0 records out
209715200 bytes (210 MB, 200 MiB) copied, 2.59015 s, 81.0 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
After using the TF card, uninstall it with umount before ejecting it.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} umount /run/media/boot\PYGZhy{}mmcblk1p1
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Note: Plug and unplug the TF card after exiting the TF card mounting path.}


\section{4.10 EMMC Test}
\label{\detokenize{linux-manual:emmc-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform eMMC runs in HS400 mode 200MHz clock by default. The following is a simple eMMC read/write speed test: taking the read/write ext4 file system as an example.\\
Write test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/zero of=/data.img bs=1M count=500 conv=fsync oflag=direct
500+0 records in
500+0 records out
524288000 bytes (524 MB, 500 MiB) copied, 4.43111 s, 118 MB/s
\end{sphinxVerbatim}

\sphinxAtStartPar
Read test：\\
\sphinxstylestrong{Note: To make sure the data is accurate, please restart the development board and test the reading speed}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/data.img of=/dev/null bs=1M count=500 iflag=direct
500+0 records in
500+0 records out
524288000 bytes (524 MB, 500 MiB) copied, 2.80064 s, 187 MB/s
\end{sphinxVerbatim}


\section{4.11 USB}
\label{\detokenize{linux-manual:usb}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports 1 x USB 3.0 port, 3 x USB 2.0 ports, and 1 x OTG port (which only supports Host mode; Device mode is only available for firmware flashing). Users can connect USB mouse, USB keyboard, U disk and other devices on the on\sphinxhyphen{}board USB HOST interface, and support the hot plug of the above devices.\\
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Support hot\sphinxhyphen{}plugging of USB flash drive devices;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{If NTFS isn’t supported and you’re unsure of the USB drive’s format, it’s best to format it to FAT32 before using it.}

\end{itemize}


\subsection{4.11.1 USB2.0}
\label{\detokenize{linux-manual:usb2-0}}
\sphinxAtStartPar
Connect the USB mouse to the USB interface of the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform, and the print information of the serial port terminal is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[   28.641316] usb 3\PYGZhy{}1.1: new low\PYGZhy{}speed USB device number 4 using xhci\PYGZhy{}hcd
[   28.805272] input: Elan Lenovo USB Optical Mouse as /devices/platform/soc@0/32f10108.usb/38200000.usb/xhci\PYGZhy{}hcd.1.auto/usb3/3\PYGZhy{}1/3\PYGZhy{}1.1/3\PYGZhy{}1.1:1.0/0003:17EF:608D.0001/input/input4
[   28.821934] hid\PYGZhy{}generic 0003:17EF:608D.0001: input: USB HID v1.11 Mouse [Elan Lenovo USB Optical Mouse] on usb\PYGZhy{}xhci\PYGZhy{}hcd.1.auto\PYGZhy{}1.1/input0
\end{sphinxVerbatim}

\sphinxAtStartPar
At this time, the arrow cursor appears on the screen, the mouse can work normally.\\
Next, take the U disk as an example for demonstration.\\
The terminal prints information about the USB flash drive, and since many types of USB flash drives exist, the information displayed may vary:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
After the development board starts, insert the USB disk into the USB2.0 host interface on the development board.\\
Serial port information:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[  343.438673] usb 3\PYGZhy{}1.1: new high\PYGZhy{}speed USB device number 4 using xhci\PYGZhy{}hcd
[  343.547026] usb\PYGZhy{}storage 3\PYGZhy{}1.1:1.0: USB Mass Storage device detected
[  343.553832] scsi host0: usb\PYGZhy{}storage 3\PYGZhy{}1.1:1.0
[  344.581363] scsi 0:0:0:0: Direct\PYGZhy{}Access     SCSI     DISK             1.00 PQ: 0 ANSI: 4
[  344.590662] sd 0:0:0:0: [sda] 31223936 512\PYGZhy{}byte logical blocks: (16.0 GB/14.9 GiB)
[  344.598526] sd 0:0:0:0: [sda] Write Protect is off
[  344.603887] sd 0:0:0:0: [sda] No Caching mode page found
[  344.609236] sd 0:0:0:0: [sda] Assuming drive cache: write through
[  344.617388]  sda: sda1
[  344.620171] sd 0:0:0:0: [sda] Attached SCSI removable disk
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Check the mount directory:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls /run/media/
Boot\PYGZhy{}mmcblk2p1  sda1
\end{sphinxVerbatim}

\sphinxAtStartPar
sda1 is the first partition of the first connected USB storage device, and so on.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
View the contents of the USB flash drive.：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls \PYGZhy{}l /run/media/sda1
total 4096000
\PYGZhy{}rwxrwx\PYGZhy{}\PYGZhy{}\PYGZhy{} 1 root disk 4194304000 Mar 22 16:34 test
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Write test: Write speeds are limited by the specific storage device:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/zero of=/run/media/sda1/test bs=100M count=40 \PYGZbs{}
conv=fsync oflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 354.351 s, 11.8 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Read test:

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: To make sure the data is accurate, please restart the development board and test the reading speed.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/run/media/sda1/test of=/dev/null bs=100M iflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 172.192 s, 24.4 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
Before removing the USB flash drive, it’s necessary to unmount it using ‘’umount’’.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} umount /run/media/sda1
\end{sphinxVerbatim}

\sphinxAtStartPar
Unmount the path before removing the USB flash drive.


\subsection{4.11.2 USB3.0}
\label{\detokenize{linux-manual:usb3-0}}
\sphinxAtStartPar
Use mounting a USB flash drive as an example for demonstration.\\
The terminal prints information about the USB flash drive, and since many types of USB flash drives exist, the information displayed may vary:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
After the development board starts up, insert the USB flash drive into the USB 3.0 port of the board.\\
Serial port information:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[  163.749673] usb 4\PYGZhy{}1: new SuperSpeed USB device number 2 using xhci\PYGZhy{}hcd
[  163.798105] usb\PYGZhy{}storage 4\PYGZhy{}1:1.0: USB Mass Storage device detected
[  163.806026] scsi host0: usb\PYGZhy{}storage 4\PYGZhy{}1:1.0
[  164.838542] scsi 0:0:0:0: Direct\PYGZhy{}Access     Kingston DataTraveler 3.0      PQ: 0 ANSI: 6
[  164.847731] sd 0:0:0:0: [sda] 241660916 512\PYGZhy{}byte logical blocks: (124 GB/115 GiB)
[  164.855892] sd 0:0:0:0: [sda] Write Protect is off
[  164.861012] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn\PYGZsq{}t support DPO or FUA
[  164.872657]  sda: sda1
[  164.875497] sd 0:0:0:0: [sda] Attached SCSI removable disk
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Check the mount directory:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls /run/media/
Boot\PYGZhy{}mmcblk2p1  sda1
\end{sphinxVerbatim}

\sphinxAtStartPar
sda1 is the first partition of the first connected USB storage device, and so on.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
View the contents of the USB flash drive.：：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls \PYGZhy{}l /run/media/sda1
total 4096000
\PYGZhy{}rwxrwx\PYGZhy{}\PYGZhy{}\PYGZhy{} 1 root disk 4194304000 Mar 22 16:34 test
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Write test: Write speeds are limited by the specific storage device:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/zero of=/run/media/sda1/test bs=100M count=40 \PYGZbs{}
conv=fsync oflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 197.547 s, 21.2 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Read test:

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: To make sure the data is accurate, please restart the development board and test the reading speed.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/run/media/sda1/test of=/dev/null bs=100M iflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 37.7027 s, 111 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
\sphinxAtStartPar
Before removing the USB flash drive, it’s necessary to unmount it using ‘’umount’’.

\end{enumerate}

\sphinxAtStartPar
root@ok\sphinxhyphen{}mx8mpq\sphinxhyphen{}smarc:\textasciitilde{}\# umount /run/media/sda1\\
\sphinxstylestrong{Note: Unplug the USB flash disk after exiting the mount path.}


\subsection{4.11.3 Micro\sphinxhyphen{}USB}
\label{\detokenize{linux-manual:micro-usb}}
\sphinxAtStartPar
Micro\sphinxhyphen{}USB can be used as the HOST side; for example, this is demonstrated by mounting a USB flash drive.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
After the development board starts, connect the USB flash drive to the Micro\sphinxhyphen{}USB port using a USB cable.\\
Serial port information:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[  109.407327] usb 1\PYGZhy{}1: new high\PYGZhy{}speed USB device number 2 using xhci\PYGZhy{}hcd
[  109.564425] usb\PYGZhy{}storage 1\PYGZhy{}1:1.0: USB Mass Storage device detected
[  109.571876] scsi host0: usb\PYGZhy{}storage 1\PYGZhy{}1:1.0
[  110.597987] scsi 0:0:0:0: Direct\PYGZhy{}Access      USB      SanDisk 3.2Gen1 1.00 PQ: 0 ANSI: 6
[  110.607733] sd 0:0:0:0: [sda] 60125184 512\PYGZhy{}byte logical blocks: (30.8 GB/28.7 GiB)
[  110.616255] sd 0:0:0:0: [sda] Write Protect is off
[  110.621442] sd 0:0:0:0: [sda] Write cache: disabled, read cache: enabled, doesn\PYGZsq{}t support DPO or FUA
[  110.645161]  sda: sda1
[  110.647846] sd 0:0:0:0: [sda] Attached SCSI removable disk
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Check the mount directory:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ls /run/media/
Boot\PYGZhy{}mmcblk2p1  sda1
\end{sphinxVerbatim}

\sphinxAtStartPar
“sda1” represents the first partition of the first USB storage device inserted, and so forth.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Write test: The write speed is limited by the specific storage device.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/zero of=/run/media/sda1/test bs=100M count=40 \PYGZbs{}
conv=fsync oflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 283.871 s, 14.8 MB/s
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Read the test:

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: To make sure the data is accurate, please restart the development board and test the reading speed.}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/run/media/sda1/test of=/dev/null bs=100M iflag=direct
40+0 records in
40+0 records out
4194304000 bytes (4.2 GB, 3.9 GiB) copied, 131.639 s, 31.9 MB/s
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} umount /run/media/sda1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Before removing the USB flash drive, it’s necessary to unmount it using ‘’umount’’.

\end{enumerate}

\sphinxAtStartPar
\sphinxstylestrong{Note: Unplug the USB disk after exiting the mount path.}

\sphinxAtStartPar
The Micro\sphinxhyphen{}USB port can also be used as a device interface. To enable this, modify the dr\_mode of the usb\_dwc3\_0 node in the device tree to peripheral, then recompile the device tree, replace it on the development board, and reboot the board. After this, the board will function as a USB device.\\
\sphinxstylestrong{Note: The otg function is not supported. You can only switch between the host side and the device side by modifying the device tree.}\\
Insert an SD card into the SD card slot, and connect the development board’s Micro\sphinxhyphen{}USB port to the PC using a suitable USB cable. Make sure the SD card’s file system format is supported and recognized by the PC. Execute the following command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} insmod /lib/modules/`uname \PYGZhy{}a | awk \PYGZsq{}\PYGZob{}print \PYGZbs{}
\PYGZdl{}3\PYGZcb{}\PYGZsq{}`/kernel/drivers/usb/gadget/legacy/g\PYGZus{}mass\PYGZus{}storage.ko removable=1 file=/dev/mmcblk1p1
[59133.219684] Mass Storage Function, version: 2009/09/11
[59133.224922] LUN: removable file: (no medium)
[59133.229373] LUN: removable file: /dev/mmcblk1p1
[59133.234021] Number of LUNs=1
[59133.237080] g\PYGZus{}mass\PYGZus{}storage gadget.0: Mass Storage Gadget, version: 2009/09/11
[59133.244324] g\PYGZus{}mass\PYGZus{}storage gadget.0: userspace failed to provide iSerialNumber
[59133.251568] g\PYGZus{}mass\PYGZus{}storage gadget.0: g\PYGZus{}mass\PYGZus{}storage ready
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see that the PC mounts the SD card as a USB drive.


\section{4.12 Ethernet Configuration}
\label{\detokenize{linux-manual:ethernet-configuration}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC has two Gigabit NICs on board, and when plugging in the network cable to connect to the network, eth0 is factory configured with the Gigabit NIC as static IP 192.168.0.232 by default. The network card of OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC can be configured through the configuration file /etc/systemd/network/10\sphinxhyphen{}eth.network.\\
\sphinxstylestrong{Note: eth0 and eth1 are opposite to the silkscreen labels on the carrier board. eth0 corresponds to the GBE1 port on the carrier board, and eth1 corresponds to the GBE0 port.}


\subsection{4.12.1 Gigabit Ethernet Static IP Configuration}
\label{\detokenize{linux-manual:gigabit-ethernet-static-ip-configuration}}
\sphinxAtStartPar
\sphinxstylestrong{Note: The Gigabit Ethernet cards in the kernel are eth0 and eth1, and the default IP of eth0 is 192.168.0.232.}

\sphinxAtStartPar
After the development board is powered on and started normally, execute the following command to open the network configuration file/etc/systemd/network/10\sphinxhyphen{}eth. network.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} vi /etc/systemd/network/10\PYGZhy{}eth.network
\end{sphinxVerbatim}

\sphinxAtStartPar
Content as follows (slight differences may occur after software version updates; users should refer to actual information):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[Match]
Name=eth0
KernelCommandLine=!root=/dev/nfs

[Network]
Address=192.168.0.232/24
Gateway=192.168.0.1
DNS=114.114.114.114
\end{sphinxVerbatim}

\sphinxAtStartPar
Name is used to specify the network card with fixed IP;

\sphinxAtStartPar
Address is used to specify the IP address to be fixed;

\sphinxAtStartPar
Gateway is used to specify the gateway;

\sphinxAtStartPar
DNS is used to specify the name resolution server.\\
Set eth0 to get IP automatically, just delete /etc/systemd/network/10\sphinxhyphen{}eth.network. The 10\sphinxhyphen{}eth. network can also be modified to follow the 11\sphinxhyphen{}eth. network.\\
/etc/systemd/network/11\sphinxhyphen{}eth.network is the configuration file that controls eth1 and is configured to obtain the IP automatically by default. You can modify 11\sphinxhyphen{}eth.network by referring to 10\sphinxhyphen{}eth.network and configure eth1 with a fixed IP address.


\subsection{4.12.2 Ethernet Speed Test}
\label{\detokenize{linux-manual:ethernet-speed-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Test the communication speed between the development board and the computer to ensure that they can communicate properly;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{This test assumes iperf3 is pre\sphinxhyphen{}installed on Windows by default.}

\end{itemize}

\sphinxAtStartPar
To test the network speed of OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC’s eth1 interface, you can use the network speed testing tool iperf3.\\
Run iperf3 in server mode from the cmd command terminal on Windows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}iperf\PYGZhy{}3.1.3\PYGZhy{}win64\PYGZbs{}iperf\PYGZhy{}3.1.3\PYGZhy{}win64\PYGZgt{}iperf3.exe \PYGZhy{}s
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxincludegraphics{{7b398e50ab0d429ca1629c9add838679}.png}Connect the network cable to the eth1 interface. After the system starts, eth1 will automatically obtain an IP address. Then, enter the following command in the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC serial debugging terminal:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} iperf3 \PYGZhy{}c 192.168.1.165       //Please fill in the server IP address according to the actual situation
Connecting to host 192.168.1.165, port 5201
[  5] local 192.168.1.22 port 59328 connected to 192.168.1.165 port 5201
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00\PYGZhy{}1.00   sec   113 MBytes   948 Mbits/sec    0    232 KBytes       
[  5]   1.00\PYGZhy{}2.00   sec   113 MBytes   951 Mbits/sec    0    232 KBytes
[  5]   2.00\PYGZhy{}3.00   sec   113 MBytes   949 Mbits/sec    0    232 KBytes       
[  5]   3.00\PYGZhy{}4.00   sec   113 MBytes   948 Mbits/sec    0    232 KBytes       
[  5]   4.00\PYGZhy{}5.00   sec   113 MBytes   951 Mbits/sec    0    232 KBytes       
[  5]   5.00\PYGZhy{}6.00   sec   113 MBytes   950 Mbits/sec    0    232 KBytes       
[  5]   6.00\PYGZhy{}7.00   sec   113 MBytes   948 Mbits/sec    0    232 KBytes       
[  5]   7.00\PYGZhy{}8.00   sec   113 MBytes   948 Mbits/sec    0    232 KBytes       
[  5]   8.00\PYGZhy{}9.00   sec   113 MBytes   950 Mbits/sec    0    232 KBytes
[  5]   9.00\PYGZhy{}10.00  sec   113 MBytes   950 Mbits/sec    0    232 KBytes       
\PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{}
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00\PYGZhy{}10.00  sec  1.11 GBytes   949 Mbits/sec    0             sender
[  5]   0.00\PYGZhy{}10.00  sec  1.10 GBytes   948 Mbits/sec                  receiver

iperf Done.       
[root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} iperf3 \PYGZhy{}c 192.168.1.165 \PYGZhy{}R
Connecting to host 192.168.1.165, port 5201
Reverse mode, remote host 192.168.1.165 is sending
[  5] local 192.168.1.22 port 54008 connected to 192.168.1.165 port 5201
[ ID] Interval           Transfer     Bitrate
[  5]   0.00\PYGZhy{}1.00   sec   112 MBytes   936 Mbits/sec                  
[  5]   1.00\PYGZhy{}2.00   sec   112 MBytes   941 Mbits/sec                  
[  5]   2.00\PYGZhy{}3.00   sec   112 MBytes   941 Mbits/sec                  
[  5]   3.00\PYGZhy{}4.00   sec   112 MBytes   940 Mbits/sec                  
[  5]   4.00\PYGZhy{}5.00   sec   112 MBytes   940 Mbits/sec                  
[  5]   5.00\PYGZhy{}6.00   sec   112 MBytes   942 Mbits/sec                  
[  5]   6.00\PYGZhy{}7.00   sec   112 MBytes   938 Mbits/sec                  
[  5]   7.00\PYGZhy{}8.00   sec   112 MBytes   942 Mbits/sec                  
[  5]   8.00\PYGZhy{}9.00   sec   112 MBytes   941 Mbits/sec                  
[  5]   9.00\PYGZhy{}10.00  sec   112 MBytes   939 Mbits/sec                  
\PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{} \PYGZhy{}
[ ID] Interval           Transfer     Bitrate
[  5]   0.00\PYGZhy{}10.00  sec  1.09 GBytes   940 Mbits/sec                  sender
[  5]   0.00\PYGZhy{}10.00  sec  1.09 GBytes   940 Mbits/sec                  receiver

iperf Done.
\end{sphinxVerbatim}

\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC eth1 Gigabit network achieved an upload bandwidth of 948 Mbps and a download bandwidth of 940 Mbps.


\section{4.13 Network Services}
\label{\detokenize{linux-manual:network-services}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The default IP for eth0 is 192.168.0.232}.

\end{itemize}


\subsection{4.13.1 Web Services}
\label{\detokenize{linux-manual:web-services}}
\sphinxAtStartPar
\sphinxstylestrong{Note: To properly use this feature, the PC’s IP address must be in the same network segment as the development board’s.}\\
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board comes pre\sphinxhyphen{}installed with a lighttpd web server, which automatically starts on system boot. Simply input the development board’s IP address in your browser to access the web pages.

\sphinxAtStartPar
As shown in the following figure:\sphinxincludegraphics{{64aed339158345ce8a6099077af53ea3}.png}


\subsection{4.13.2 SFTP}
\label{\detokenize{linux-manual:sftp}}
\sphinxAtStartPar
See {\hyperref[\detokenize{linux-manual:../02__E5_BF_AB_E9_80_9F_E5_BC_80_E6_9C_BA_E5_90_AF_E5_8A_A8/02__E5_BF_AB_E9_80_9F_E5_BC_80_E6_9C_BA_E5_90_AF_E5_8A_A8.md:chapter2_2.3.2}]{\sphinxcrossref{\DUrole{xref}{\DUrole{myst}{2.3.2 SSH Server}}}}}


\section{4.14 WIFI Bluetooth Test}
\label{\detokenize{linux-manual:wifi-bluetooth-test}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC SoM is equipped with an AW\sphinxhyphen{}CM276NF WiFi and Bluetooth module, supporting 2.4 GHz and 5 GHz frequency bands.}

\end{itemize}


\subsection{4.14.1 WIFI STA Mode}
\label{\detokenize{linux-manual:wifi-sta-mode}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The network environment is different, so please set it according to the actual situation when you do this experiment;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The development board supports the connection of 2.4G and 5G wireless hotspots.}

\end{itemize}

\sphinxAtStartPar
This mode connects to the wireless network as a client. In the following test, the router uses wpa encryption, and the connected wifi hotspot name is: H3C\_708, and the password is: 123456785…. Due to the different network environments, users should set up according to the actual situation when conducting this test:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Enter the following command in the development board terminal:

\end{enumerate}

\sphinxAtStartPar
The meanings of the related parameters in the command are as follows:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxhyphen{}i
&
\sphinxAtStartPar
Wireless NIC Node Name
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}s
&
\sphinxAtStartPar
Actual wifi hotspot connected
\\
\sphinxhline
\sphinxAtStartPar
\sphinxhyphen{}p
&
\sphinxAtStartPar
The following parameter Password refers to the actual wifi hotspot password to connect to;
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The serial port prints as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}sta.sh \PYGZhy{}i mlan0 \PYGZhy{}s H3C\PYGZus{}708 \PYGZhy{}p 123456785.
[  182.357745] imx\PYGZhy{}dwmac 30bf0000.ethernet eth1: Link is Down
[  182.387409] imx\PYGZhy{}dwmac 30bf0000.ethernet eth1: FPE workqueue stop
[  182.488699] imx\PYGZhy{}dwmac 30bf0000.ethernet eth1: yt8521\PYGZus{}config\PYGZus{}init done, phy addr: 1, chip mode = 0, polling mode = 2
[  182.499218] imx\PYGZhy{}dwmac 30bf0000.ethernet eth1: PHY [stmmac\PYGZhy{}0:01] driver [YT8521 Ethernet] (irq=POLL)
[  182.508306] imx\PYGZhy{}dwmac 30bf0000.ethernet eth1: configuring for phy/rgmii\PYGZhy{}id link mode
wifi mlan0
ssid H3C\PYGZus{}708
pasw 123456785.
waiting...
[  183.773786] wlan: mlan0 START SCAN
wpa connect failed, retry
wpa connect failed, retry
[  188.092133] wlan: SCAN COMPLETED: scanned AP count=10
[  188.107031] wlan: HostMlme mlan0 send auth to bssid 14:XX:XX:XX:fc:84
[  188.115056] mlan0: 
[  188.115066] wlan: HostMlme Auth received from 14:XX:XX:XX:fc:84
[  188.128227] CMD\PYGZus{}RESP: cmd 0x121 error, result=0x2
[  188.132972] IOCTL failed: 00000000e3845a7f id=0x200000, sub\PYGZus{}id=0x200024 action=2, status\PYGZus{}code=0x3
[  188.142136] Get multi\PYGZhy{}channel policy failed
[  188.156780] wlan: HostMlme mlan0 Connected to bssid 14:XX:XX:XX:fc:84 successfully
[  188.166711] mlan0: 
[  188.166727] wlan: Send EAPOL pkt to 14:XX:XX:XX:fc:84
[  188.176669] mlan0: 
[  188.176681] wlan: Send EAPOL pkt to 14:XX:XX:XX:fc:84
[  188.193730] IPv6: ADDRCONF(NETDEV\PYGZus{}CHANGE): mlan0: link becomes ready
[  188.201087] woal\PYGZus{}cfg80211\PYGZus{}set\PYGZus{}rekey\PYGZus{}data return: gtk\PYGZus{}rekey\PYGZus{}offload is DISABLE
udhcpc: started, v1.36.1
Dropped protocol specifier \PYGZsq{}.udhcpc\PYGZsq{} from \PYGZsq{}mlan0.udhcpc\PYGZsq{}. Using \PYGZsq{}mlan0\PYGZsq{} (ifindex=6).
udhcpc: broadcasting discover
udhcpc: broadcasting discover
udhcpc: broadcasting select for 192.168.1.27, server 192.168.1.1
udhcpc: lease of 192.168.1.27 obtained from 192.168.1.1, lease time 86400
/etc/udhcpc.d/50default: Adding DNS 192.168.1.1
Dropped protocol specifier \PYGZsq{}.udhcpc\PYGZsq{} from \PYGZsq{}mlan0.udhcpc\PYGZsq{}. Using \PYGZsq{}mlan0\PYGZsq{} (ifindex=6).
connect ok
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Check whether it can ping the external network and enter the following command in the terminal:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ping \PYGZhy{}I mlan0 qq.com \PYGZhy{}c 3    //指定mlan0网卡ping3次
PING qq.com (157.255.219.143) from 192.168.1.26 mlan0: 56(84) bytes of data.
64 bytes from 157.255.219.143 (157.255.219.143): icmp\PYGZus{}seq=1 ttl=52 time=47.3 ms
64 bytes from 157.255.219.143 (157.255.219.143): icmp\PYGZus{}seq=2 ttl=52 time=123 ms
64 bytes from 157.255.219.143 (157.255.219.143): icmp\PYGZus{}seq=3 ttl=52 time=61.0 ms

\PYGZhy{}\PYGZhy{}\PYGZhy{} qq.com ping statistics \PYGZhy{}\PYGZhy{}
3 packets transmitted, 3 received, 0\PYGZpc{} packet loss, time 2003ms
rtt min/avg/max/mdev = 47.291/76.960/122.622/32.766 ms
\end{sphinxVerbatim}

\sphinxAtStartPar
The WiFi module requires loading the configuration file wifi\textbackslash{}\_mod\textbackslash{}\_para.conf. If the WiFi module firmware fails to load, try the following command to reload the WiFi module.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} rmmod moal
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} systemctl  restart obex
\end{sphinxVerbatim}


\subsection{4.14.2 WIFI AP Mode}
\label{\detokenize{linux-manual:wifi-ap-mode}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ensure that the Gigabit LAN card is eth1 connected to the network before performing this test.}

\end{itemize}

\sphinxAtStartPar
The hotspot name and password can be viewed in the /etc/hostapd\sphinxhyphen{}2.4g.conf** or /etc/hostapd\sphinxhyphen{}5g.conf files.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}hostapd.sh \PYGZhy{}B 5g
BAND 5g
waiting...
uap0: interface state UNINITIALIZED\PYGZhy{}\PYGZgt{}COUNTRY\PYGZus{}UPDATE
[  143.810799] wlan: Starting AP
[  143.815711] CMD\PYGZus{}RESP: cmd 0x121 error, result=0x2
[  143.820446] IOCTL failed: 000000009c917059 id=0x200000, sub\PYGZus{}id=0x200024 action=2, status\PYGZus{}code=0x2
[  143.829335] Get multi\PYGZhy{}channel policy failed
[  143.834510] fw doesn\PYGZsq{}t support 11ax
[  143.849902] IPv6: ADDRCONF(NETDEV\PYGZus{}CHANGE): uap0: link becomes ready
[  143.857435] wlan: AP started
[  143.861954] wlan: HostMlme uap0 send deauth/disassoc
[  143.867602] Set AC=3, txop=47 cwmin=3, cwmax=7 aifs=1
[  143.874873] Set AC=2, txop=94 cwmin=7, cwmax=15 aifs=1
[  143.882732] Set AC=0, txop=0 cwmin=15, cwmax=63 aifs=3
[  143.890600] Set AC=1, txop=0 cwmin=15, cwmax=1023 aifs=7
enable ap ok
udhcpd: started, v1.36.1
\end{sphinxVerbatim}

\sphinxAtStartPar
You can then use a mobile phone or other devices to connect to OK8MP\_WIFI\_5G\_AP.


\subsection{4.14.3 Bluetooth Test}
\label{\detokenize{linux-manual:bluetooth-test}}
\sphinxAtStartPar
Bluetooth Configuration

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} bluetoothctl                  //Turn on the BlueZ Bluetooth device           
Agent registered
[CHG] Controller 1C:CE:51:0D:88:92 Pairable: yes
[bluetooth]\PYGZsh{} power on          //Enable the bluetooth device
Changing power on succeeded
[bluetooth]\PYGZsh{} pairable on       //Set to Matchable Mode
Changing pairable on succeeded
[bluetooth]\PYGZsh{} discoverable on   //Set to discoverable mode
Changing discoverable on succeeded
[CHG] Controller 1C:CE:51:0D:88:92 Discoverable: yes
[bluetooth]\PYGZsh{} agent on        //Enable the agent
Agent is already registered
[bluetooth]\PYGZsh{} default\PYGZhy{}agent    //Set the current agent as the default agent
Default agent request successful
[bluetooth]\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Development Board Passive Pairing. After the above settings, open the mobile phone Bluetooth search, and a device named “ok\sphinxhyphen{}mxmpq\sphinxhyphen{}smarc” will appear. Click this Bluetooth to try to pair.\sphinxincludegraphics{{20a03c8d735d4041ae9f2cfca870f4f1}.png}At the same time, the information printed on the development board is as follows. Enter yes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[CHG] Device 14:16:9E:62:39:BD Connected: yes
Request confirmation
[agent] Confirm passkey 153732 (yes/no): yes
\end{sphinxVerbatim}

\sphinxAtStartPar
Then, tap on Bluetooth on your phone to initiate pairing.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
View and remove connected devices:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[bluetooth]\PYGZsh{} devices Paired                                //View connected Bluetooth device
Device 14:16:9E:62:39:BD zzy
[bluetooth]\PYGZsh{} remove 14:16:9E:62:39:BD                         //Remove the device
[DEL] Device 14:16:9E:62:39:BD zzy
Device has been removed
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Development Board Active: Pairing In addition to passive pairing, you can also send a request for active pairing at the development board terminal.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bluetooth]\PYGZsh{} scan on        //Scan on
Discovery started
[CHG] Controller E8:FB:1C:66:FA:A6 Discovering: yes
[NEW] Device 7B:01:59:ED:69:50 7B\PYGZhy{}01\PYGZhy{}59\PYGZhy{}ED\PYGZhy{}69\PYGZhy{}50
[NEW] Device 7C:71:13:5F:A3:8F 7C\PYGZhy{}71\PYGZhy{}13\PYGZhy{}5F\PYGZhy{}A3\PYGZhy{}8F
[NEW] Device 14:16:9E:62:39:BD zzy  //Locate the device to pair
[NEW] Device 2C:DB:07:C7:4F:F6 DESKTOP\PYGZhy{}VND9V1F
[CHG] Device 14:16:9E:62:39:BD RSSI: \PYGZhy{}74
[bluetooth]\PYGZsh{} scan off        //Scan off
Discovery stopped
[CHG] Device 2C:DB:07:C7:4F:F6 TxPower is nil
[CHG] Device 2C:DB:07:C7:4F:F6 RSSI is nil
[CHG] Device 14:16:9E:62:39:BD RSSI is nil
[CHG] Device 7C:71:13:5F:A3:8F TxPower is nil
[CHG] Device 7C:71:13:5F:A3:8F RSSI is nil
[CHG] Device 7B:01:59:ED:69:50 RSSI is nil
[CHG] Controller E8:FB:1C:66:FA:A6 Discovering: no
[bluetooth]\PYGZsh{} pair 14:16:9E:62:39:BD        //Pair with the specified device
Attempting to pair with 14:16:9E:62:39:BD
[CHG] Device 14:16:9E:62:39:BD Connected: yes
Request confirmation
[agent] Confirm passkey 807166 (yes/no): yes        //Confirm the key
[CHG] Device 14:16:9E:62:39:BD Modalias: bluetooth:v000Fp1200d1436
[CHG] Device 14:16:9E:62:39:BD UUIDs: 00001105\PYGZhy{}0000\PYGZhy{}1000\PYGZhy{}8000\PYGZhy{}00805f9b34fb
......
[CHG] Device 14:16:9E:62:39:BD UUIDs: fa88c0d0\PYGZhy{}afac\PYGZhy{}11de\PYGZhy{}8a99\PYGZhy{}0800200c9a67
[CHG] Device 14:16:9E:62:39:BD ServicesResolved: yes
[CHG] Device 14:16:9E:62:39:BD Paired: yes
Pairing successful
[CHG] Device 14:16:9E:62:39:BD ServicesResolved: no
[CHG] Device 14:16:9E:62:39:BD Connected: no
[bluetooth]\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
At the same time, the pairing request appears on the mobile phone interface. Click the pairing button, and the board end prints and inputs yes. The pairing on the mobile phone end is successful.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Development Board Receives Files

\end{enumerate}

\sphinxAtStartPar
After successful pairing, files can be sent from the mobile device to the board via Bluetooth.\\
Start obexd at the board end.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} /usr/libexec/bluetooth/obexd \PYGZhy{}a \PYGZhy{}r /tmp \PYGZam{}
\end{sphinxVerbatim}

\sphinxAtStartPar
By default, received files are saved in the /tmp/ directory.\\
When receiving is complete, close obexd.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} killall obexd
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Sending Files from Development Board Similarly, you can use the development board to send files to the mobile phone, the test method is as follows:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} bluetoothctl 
Agent registered
[CHG] Controller 1C:CE:51:0D:88:92 Pairable: yes
[bluetooth]\PYGZsh{} devices  Paired        //View paired device
Device 14:16:9E:62:39:BD zzy
[bluetooth]\PYGZsh{} exit
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} /usr/libexec/bluetooth/obexd \PYGZhy{}a \PYGZhy{}r /tmp \PYGZam{}
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} obexctl 
[NEW] Client /org/bluez/obex 
[obex]\PYGZsh{} connect   14:16:9E:62:39:BD     //Link the specified device
Attempting to connect to 14:16:9E:62:39:BD
[NEW] Session /org/bluez/obex/client/session0 [default]
[NEW] ObjectPush /org/bluez/obex/client/session0 
Connection successful
[14:16:9E:62:39:BD]\PYGZsh{} send /home/forlinx/logo/logo\PYGZhy{}1920x1080.bmp  //Send files
Attempting to send /home/forlinx/logo/logo\PYGZhy{}1920x1080.bmp to /org/bluez/obex/client/session0
[NEW] Transfer /org/bluez/obex/client/session0/transfer0
Transfer /org/bluez/obex/client/session0/transfer0
        Status: queued
        Name: logo\PYGZhy{}1920x1080.bmp
        Size: 6220854
        Filename: /home/forlinx/logo/logo\PYGZhy{}1920x1080.bmp
        Session: /org/bluez/obex/client/session0
[CHG] Transfer /org/bluez/obex/client/session0/transfer0 Status: active
[CHG] Transfer /org/bluez/obex/client/session0/transfer0 Transferred: 65477 (@65KB/s 01:34)
[CHG] Transfer /org/bluez/obex/client/session0/transfer0 Transferred: 131005 (@65KB/s 01:32)
.....
[CHG] Transfer /org/bluez/obex/client/session0/transfer0 Status: complete
[DEL] Transfer /org/bluez/obex/client/session0/transfer0
[14:16:9E:62:39:BD]\PYGZsh{} exit
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
The phone will receive the incoming file request and click Accept to transfer the file.\sphinxincludegraphics{{ee86c59858e148099e88dd27fd40c44d}.png}


\section{4.15 4G/5G Test}
\label{\detokenize{linux-manual:id4}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The driver supports the 4G module of EM05 and the 5G module of RM500U\sphinxhyphen{}CN and RM500Q\sphinxhyphen{}GL;}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Before powering on the device, set the S4 dial\sphinxhyphen{}up code to be the same as the plug\sphinxhyphen{}in module.}

\end{itemize}

\sphinxAtStartPar
Access the module before starting the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board, install the antenna, insert the SIM card, set the S4 dial to the 4G end, start the development board, and perform dial\sphinxhyphen{}up Internet access. Take 4G as an example..
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
After connecting the module and powering up the development board and the module, you can use the lsusb command to see if the module is recognized.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} lsusb
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 003: ID 1a86:7523 QinHeng Electronics CH340 serial converter
Bus 003 Device 004: ID 2c7c:0125 Quectel Wireless Solutions Co., Ltd. EC25 LTE modem
Bus 003 Device 002: ID 0424:2517 Microchip Technology, Inc. (formerly SMSC) Hub
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
After the equipment is successfully identified, the dial\sphinxhyphen{}up Internet access test can be conducted.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} fltest\PYGZus{}quectel.sh \PYGZam{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Printing information is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[1] 1078
[03\PYGZhy{}26\PYGZus{}12:14:20:191] Quectel\PYGZus{}QConnectManager\PYGZus{}Linux\PYGZus{}V1.6.0.24
[03\PYGZhy{}26\PYGZus{}12:14:20:192] Find /sys/bus/usb/devices/3\PYGZhy{}1.2 idVendor=0x2c7c idProduct=0x125, bus=0x003, dev=0x004
[03\PYGZhy{}26\PYGZus{}12:14:20:193] Auto find qmichannel = /dev/qcqmi0
[03\PYGZhy{}26\PYGZus{}12:14:20:193] Auto find usbnet\PYGZus{}adapter = usb0
[03\PYGZhy{}26\PYGZus{}12:14:20:193] netcard driver = GobiNet, driver version = V1.6.2.14
[03\PYGZhy{}26\PYGZus{}12:14:20:193] Modem works in QMI mode
[03\PYGZhy{}26\PYGZus{}12:14:20:223] Get clientWDS = 7
[03\PYGZhy{}26\PYGZus{}12:14:20:256] Get clientDMS = 8
[03\PYGZhy{}26\PYGZus{}12:14:20:288] Get clientNAS = 9
[03\PYGZhy{}26\PYGZus{}12:14:20:320] Get clientUIM = 10
[03\PYGZhy{}26\PYGZus{}12:14:20:353] Get clientWDA = 11
[03\PYGZhy{}26\PYGZus{}12:14:20:385] requestBaseBandVersion EM05CEFCR06A02M1G\PYGZus{}ND
[03\PYGZhy{}26\PYGZus{}12:14:20:513] requestGetSIMStatus SIMStatus: SIM\PYGZus{}READY
[03\PYGZhy{}26\PYGZus{}12:14:20:545] requestGetProfile[1] cmnet///0
[03\PYGZhy{}26\PYGZus{}12:14:20:577] requestRegistrationState2 MCC: 460, MNC: 1, PS: Attached, DataCap: LTE
[03\PYGZhy{}26\PYGZus{}12:14:20:609] requestQueryDataCall IPv4ConnectionStatus: DISCONNECTED
[03\PYGZhy{}26\PYGZus{}12:14:20:609] ifconfig usb0 0.0.0.0
[03\PYGZhy{}26\PYGZus{}12:14:20:624] ifconfig usb0 down
[   50.315332] GobiNet 3\PYGZhy{}1.2:1.4: Runtime PM usage count underflow!
[03\PYGZhy{}26\PYGZus{}12:14:20:705] requestSetupDataCall WdsConnectionIPv4Handle: 0x86d0ee80
[03\PYGZhy{}26\PYGZus{}12:14:20:865] ifconfig usb0 up
[03\PYGZhy{}26\PYGZus{}12:14:20:883] busybox udhcpc \PYGZhy{}f \PYGZhy{}n \PYGZhy{}q \PYGZhy{}t 5 \PYGZhy{}i usb0
udhcpc: started, v1.36.1
Dropped protocol specifier \PYGZsq{}.udhcpc\PYGZsq{} from \PYGZsq{}usb0.udhcpc\PYGZsq{}. Using \PYGZsq{}usb0\PYGZsq{} (ifindex=9).
[   50.645653] IPv6: ADDRCONF(NETDEV\PYGZus{}CHANGE): usb0: link becomes ready
[   50.754730] GobiNet 3\PYGZhy{}1.2:1.4: Runtime PM usage count underflow!
[   50.776986] audit: type=1334 audit(1711426461.092:18): prog\PYGZhy{}id=15 op=LOAD
[   50.784633] audit: type=1334 audit(1711426461.100:19): prog\PYGZhy{}id=16 op=LOAD
udhcpc: broadcasting discover
udhcpc: broadcasting select for 10.223.229.79, server 10.223.229.80
udhcpc: lease of 10.223.229.79 obtained from 10.223.229.80, lease time 7200
[03\PYGZhy{}26\PYGZus{}12:14:21:471] /etc/udhcpc.d/50default: Adding DNS 123.123.123.123
[03\PYGZhy{}26\PYGZus{}12:14:21:471] /etc/udhcpc.d/50default: Adding DNS 123.123.123.124
Dropped protocol specifier \PYGZsq{}.udhcpc\PYGZsq{} from \PYGZsq{}usb0.udhcpc\PYGZsq{}. Using \PYGZsq{}usb0\PYGZsq{} (ifindex=9)
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you can automatically assign IP and add DNS, the dialling is successful.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
After successfully dialing, use the ifconfig command to check the network interface, which is typically named usb0 (the interface name may vary depending on the actual situation). Then, test the network status using the ping command.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ping \PYGZhy{}I usb0 www.forlinx.com \PYGZhy{}c 3
PING s\PYGZhy{}526319.gotocdn.com (211.149.226.120) from 10.230.5.117 usb0: 56(84) bytes of data.
64 bytes from 211.149.226.120 (211.149.226.120): icmp\PYGZus{}seq=1 ttl=51 time=63.5 ms
64 bytes from 211.149.226.120 (211.149.226.120): icmp\PYGZus{}seq=2 ttl=51 time=80.5 ms
64 bytes from 211.149.226.120 (211.149.226.120): icmp\PYGZus{}seq=3 ttl=51 time=61.9 ms

\PYGZhy{}\PYGZhy{}\PYGZhy{} s\PYGZhy{}526319.gotocdn.com ping statistics \PYGZhy{}\PYGZhy{}\PYGZhy{}
3 packets transmitted, 3 received, 0\PYGZpc{} packet loss, time 2004ms
rtt min/avg/max/mdev = 61.945/68.625/80.452/8.385 ms
\end{sphinxVerbatim}


\section{4.16 Play/Record Test}
\label{\detokenize{linux-manual:id5}}
\sphinxAtStartPar
\sphinxstylestrong{Description:}\\
\sphinxstylestrong{OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC provides 1 x 3.5mm audio jack and 2 x PH2.0 speaker connectors. The earphone mic and the carrier board mic correspond to the left and right channels of the recording, respectively. By default, the sound is played by the speakers, and after plugging in the headphones, it is switched to play by the headphones and mute the speakers.}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use aplay to play audio

\end{enumerate}

\sphinxAtStartPar
Check the device number corresponding to the audio chip NAU88C22:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} aplay \PYGZhy{}l
**** List of PLAYBACK Hardware Devices ****
card 0: audiohdmi [audio\PYGZhy{}hdmi], device 0: i.MX HDMI i2s\PYGZhy{}hifi\PYGZhy{}0 [i.MX HDMI i2s\PYGZhy{}hifi\PYGZhy{}0]
  Subdevices: 1/1
  Subdevice \PYGZsh{}0: subdevice \PYGZsh{}0
card 1: nau88c22audio [nau88c22\PYGZhy{}audio], device 0: HiFi nau8822\PYGZhy{}hifi\PYGZhy{}0 [HiFi nau8822\PYGZhy{}hifi\PYGZhy{}0]
Subdevices: 1/1
  Subdevice \PYGZsh{}0: subdevice \PYGZsh{}0
card 1: nau88c22audio [nau88c22\PYGZhy{}audio], device 1: HiFi\PYGZhy{}ASRC\PYGZhy{}FE (*) []
  Subdevices: 1/1
  Subdevice \PYGZsh{}0: subdevice \PYGZsh{}0
\end{sphinxVerbatim}

\sphinxAtStartPar
As above, when playing, the device corresponding to nau88c88 is card1, and either device0 or device1 can be used. (The equipment number may be different in actual use)

\sphinxAtStartPar
Playback test:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} aplay \PYGZhy{}D hw:1,0 \PYGZhy{}f cd /home/forlinx/audio/30s.wav
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Use the gstreamer playback audio device to view the available sound cards

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} pactl list sinks
Sink \PYGZsh{}0
        State: SUSPENDED
        Name: alsa\PYGZus{}output.platform\PYGZhy{}sound\PYGZhy{}hdmi.stereo\PYGZhy{}fallback
......
Sink \PYGZsh{}1
        State: SUSPENDED
        Name: alsa\PYGZus{}output.platform\PYGZhy{}sound\PYGZhy{}nau88c22.stereo\PYGZhy{}fallback
......
\end{sphinxVerbatim}

\sphinxAtStartPar
Set nau88c22 as the default sound card for playback

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} pactl set\PYGZhy{}default\PYGZhy{}sink 1
\end{sphinxVerbatim}

\sphinxAtStartPar
Video play

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}play\PYGZhy{}1.0 /home/forlinx/audio/30s.mp3
\end{sphinxVerbatim}

\sphinxAtStartPar
Pressing the up and down keys on the keyboard adjusts the volume level, while the left and right keys control fast\sphinxhyphen{}forwarding or rewinding. The spacebar is used to start or pause playback.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Recording Test

\end{enumerate}

\sphinxAtStartPar
Check the device number corresponding to the audio chip NAU88C22:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} arecord \PYGZhy{}l
**** List of CAPTURE Hardware Devices ****
card 1: nau88c22audio [nau88c22\PYGZhy{}audio], device 0: HiFi nau8822\PYGZhy{}hifi\PYGZhy{}0 [HiFi nau8822\PYGZhy{}hifi\PYGZhy{}0]
  Subdevices: 1/1
  Subdevice \PYGZsh{}0: subdevice \PYGZsh{}0
card 1: nau88c22audio [nau88c22\PYGZhy{}audio], device 1: HiFi\PYGZhy{}ASRC\PYGZhy{}FE (*) []
  Subdevices: 1/1
  Subdevice \PYGZsh{}0: subdevice \PYGZsh{}0
\end{sphinxVerbatim}

\sphinxAtStartPar
As mentioned, the device corresponding to nau88c88 is card1, device0. (\sphinxstylestrong{Note: In actual use, the device numbers may vary.})

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} arecord \PYGZhy{}D hw:1,0 \PYGZhy{}c2 \PYGZhy{}f cd \PYGZhy{}d 10 mic.wav
Recording WAVE \PYGZsq{}mic.wav\PYGZsq{} : Signed 16 bit Little Endian, Rate 48000 Hz, Stereo
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxhyphen{}c2, dual channel

\sphinxAtStartPar
\sphinxhyphen{}f cd, 16 bit little endian, 44100, stereo

\sphinxAtStartPar
\sphinxhyphen{}d10, record for 10 second

\sphinxAtStartPar
The default recording will capture the headphone mic and the carrier board mic as the left and right channels of the recording respectively.


\section{4.17 Closing the Desktop}
\label{\detokenize{linux-manual:closing-the-desktop}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} systemctl stop matrix                      //Turn off the desktop
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} systemctl start matrix                      //Turn on the desktop
\end{sphinxVerbatim}


\section{4.18 LED Test}
\label{\detokenize{linux-manual:led-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC SoM has a controllable blue LED light. When the board is powered on, the blue LED light will blink.\\
The testing method is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
To view trigger conditions:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/class/leds/heartbeat/trigger
none rc\PYGZhy{}feedback rfkill\PYGZhy{}any kbd\PYGZhy{}scrolllock kbd\PYGZhy{}numlock kbd\PYGZhy{}capslock kbd\PYGZhy{}kanalock kbd\PYGZhy{}shiftlock kbd\PYGZhy{}altgrlock kbd\PYGZhy{}ctrllock kbd\PYGZhy{}altlock kbd\PYGZhy{}shiftllock kbd\PYGZhy{}shiftrlock kbd\PYGZhy{}ctrlllock kbd\PYGZhy{}ctrlrlock mmc0 mmc1 mmc2 timer oneshot [heartbeat] gpio cpu cpu0 cpu1 cpu2 cpu3 cpu4 cpu5 default\PYGZhy{}on rfkill0 bluetooth\PYGZhy{}power hci0\PYGZhy{}power rfkill1
\end{sphinxVerbatim}

\sphinxAtStartPar
Where {[}heartbeat{]} indicates that the current trigger condition is the system heartbeat light. Write the above string in trigger to modify the trigger condition.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
User Control When the led trigger condition is set to none, the user can control the on and off of the led lamp through the command:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo none \PYGZgt{} /sys/class/leds/heartbeat/trigger
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo 1 \PYGZgt{} /sys/class/leds/heartbeat/brightness
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo 0 \PYGZgt{} /sys/class/leds/heartbeat/brightness
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Change the LED light to heartbeat light

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo heartbeat \PYGZgt{} /sys/class/leds/heartbeat/trigger
\end{sphinxVerbatim}

\sphinxAtStartPar
At this time, the LED light becomes a heartbeat light.


\section{4.19 SQLite3 Test}
\label{\detokenize{linux-manual:sqlite3-test}}
\sphinxAtStartPar
SQLite3 is a lightweight, ACID\sphinxhyphen{}compliant relational database management system with a low footprint. The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board is ported with version 3.41.0 of sqlit3.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} sqlite3
SQLite version 3.41.0 2023\PYGZhy{}02\PYGZhy{}21 18:09:37
Enter \PYGZdq{}.help\PYGZdq{} for usage hints.
Connected to a transient in\PYGZhy{}memory database.
Use \PYGZdq{}.open FILENAME\PYGZdq{} to reopen on a persistent database.
sqlite\PYGZgt{} create table tbl1 (one varchar(10), two smallint);         //Create table tbl1
sqlite\PYGZgt{} insert into tbl1 values(\PYGZsq{}hello!\PYGZsq{},10);                      //Insert data hello!|10 in table tbl1 
sqlite\PYGZgt{} insert into tbl1 values(\PYGZsq{}goodbye\PYGZsq{}, 20);                  //Insert dataoodbye|20 in table tbl1
sqlite\PYGZgt{} select * from tbl1;                                   //Query the content in table tbl1
hello!|10
goodbye|20
sqlite\PYGZgt{} delete from tbl1 where one = \PYGZsq{}hello!\PYGZsq{};                  //Delete the data
sqlite\PYGZgt{} select * from tbl1;                                   //Query the content in table tbl1
goodbye|20
sqlite\PYGZgt{} .quit 			                                     //Exit the database (or use the.exit command)
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}


\section{4.20 PWM Test}
\label{\detokenize{linux-manual:pwm-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board has a total of 3 x PWM. PWM1 and PWM2 are used for the backlight of the LVDS0 and LVDS1 displays, respectively. PWM3 is used as a cooling fan on the carrier board.


\subsection{4.20.1 Screen Backlight Test}
\label{\detokenize{linux-manual:screen-backlight-test}}
\sphinxAtStartPar
The brightness of the screen backlight is set in the range of (0\sphinxhyphen{}255) 255 means the highest brightness and 0 means the backlight is completely off. After entering the system, input the following command at the terminal for backlight test
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
View lvds1 screen backlight:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cat /sys/class/backlight/lvds1\PYGZus{}backlight/brightness
250
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Turn off the backlight of the LVDS1 screen.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo 0 \PYGZgt{} /sys/class/backlight/lvds1\PYGZus{}backlight/brightness
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Switch on the LVDS1 screen backlight.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo 255 \PYGZgt{} /sys/class/backlight/lvds1\PYGZus{}backlight/brightness
\end{sphinxVerbatim}


\section{4.21 CAN Test}
\label{\detokenize{linux-manual:can-test}}

\subsection{4.21.1 CAN Test}
\label{\detokenize{linux-manual:id6}}
\sphinxAtStartPar
There are 2 x CAN buses on the carrier board, both supporting CAN FD, routed to the P27 connector. The maximum bitrate supported is 1m\\
Short H, L, and GND of can0 and can1, respectively, to test.\\
Set the Can service：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set can0 up type can bitrate 1000000
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set can1 up type can bitrate 1000000
\end{sphinxVerbatim}

\sphinxAtStartPar
Set can0 to receive and can1 to send:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} candump can0 \PYGZam{}
[1] 1305
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cangen  can1
  can0  290   [3]  07 7C 1A
  can0  242   [5]  D5 DA F1 05 1B
  can0  46F   [8]  42 12 71 2D 68 14 83 49
  can0  725   [8]  03 E8 6B 02 A5 7A 03 36
  can0  025   [6]  85 55 A3 77 90 32
  can0  5D1   [6]  F3 02 C1 61 D9 67
  can0  078   [0]
\end{sphinxVerbatim}

\sphinxAtStartPar
Set up the CAN FD service.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set can0 up type can bitrate 1000000 dbitrate 4000000 fd on
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set can1 up type can bitrate 1000000 dbitrate 4000000 fd on
\end{sphinxVerbatim}

\sphinxAtStartPar
Set can1 to receive and can0 to send:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} candump can1 \PYGZam{}
[1] 1326
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cangen  can0 \PYGZhy{}f
  can1  1D9  [02]  00 6A
  can1  475  [32]  86 1D 18 43 84 89 76 37 86 1D 18 43 84 89 76 37 86 1D 18 43 84 89 76 37 86 1D 18 43 84 89 76 37
  can1  261  [07]  A9 88 2D 3D BF 8A 31
  can1  606  [06]  37 65 17 0B A2 4D
  can1  0C8  [04]  DF 60 79 3F
  can1  50B  [02]  C4 46
  can1  40A  [16]  71 8F F5 22 51 67 3C 6B 71 8F F5 22 51 67 3C 6B
  can1  29A  [02]  3C 58
  can1  294  [32]  FA DF 4D 02 09 D7 84 31 FA DF 4D 02 09 D7 84 31 FA DF 4D 02 09 D7 84 31 FA DF 4D 02 09 D7 84 31
  can1  16A  [00] 
  can1  537  [06]  8A 4E 51 19 3E 1B
  can1  28D  [01]  E0
\end{sphinxVerbatim}


\subsection{4.21.2 Other Common Commands}
\label{\detokenize{linux-manual:other-common-commands}}
\sphinxAtStartPar
Check CAN bus status:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip \PYGZhy{}details \PYGZhy{}statistics link show can0
4: can0: \PYGZlt{}NOARP,UP,LOWER\PYGZus{}UP,ECHO\PYGZgt{} mtu 72 qdisc pfifo\PYGZus{}fast state UP mode DEFAULT group default qlen 10
    link/can  promiscuity 0  allmulti 0 minmtu 0 maxmtu 0 
    can \PYGZlt{}FD\PYGZgt{} state ERROR\PYGZhy{}ACTIVE (berr\PYGZhy{}counter tx 0 rx 0) restart\PYGZhy{}ms 0 
          bitrate 1000000 sample\PYGZhy{}point 0.750
          tq 25 prop\PYGZhy{}seg 14 phase\PYGZhy{}seg1 15 phase\PYGZhy{}seg2 10 sjw 1 brp 1
          flexcan: tseg1 2..96 tseg2 2..32 sjw 1..16 brp 1..1024 brp\PYGZus{}inc 1
          dbitrate 8000000 dsample\PYGZhy{}point 0.600
          dtq 25 dprop\PYGZhy{}seg 1 dphase\PYGZhy{}seg1 1 dphase\PYGZhy{}seg2 2 dsjw 1 dbrp 1
          flexcan: dtseg1 2..39 dtseg2 2..8 dsjw 1..4 dbrp 1..1024 dbrp\PYGZus{}inc 1
          clock 40000000 
          re\PYGZhy{}started bus\PYGZhy{}errors arbit\PYGZhy{}lost error\PYGZhy{}warn error\PYGZhy{}pass bus\PYGZhy{}off
          0          0          0          0          0          0         numtxqueues 1 numrxqueues 1 gso\PYGZus{}max\PYGZus{}size 65536 gso\PYGZus{}max\PYGZus{}segs 65535 tso\PYGZus{}max\PYGZus{}size 65536 tso\PYGZus{}max\PYGZus{}segs 65535 gro\PYGZus{}max\PYGZus{}size 65536 parentbus platform parentdev 308c0000.can 
    RX:  bytes packets errors dropped  missed   mcast           
          2176     309      0       0       0       0 
    TX:  bytes packets errors dropped carrier collsns           
           679      54      0       0       0       0
\end{sphinxVerbatim}

\sphinxAtStartPar
Set the bus\sphinxhyphen{}off reset time of the bus:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ifconfig can0 down
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set can0 type can restart\PYGZhy{}ms 100
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip \PYGZhy{}details \PYGZhy{}statistics link show can0
4: can0: \PYGZlt{}NOARP,ECHO\PYGZgt{} mtu 72 qdisc pfifo\PYGZus{}fast state DOWN mode DEFAULT group default qlen 10
    link/can  promiscuity 0  allmulti 0 minmtu 0 maxmtu 0
    can \PYGZlt{}FD\PYGZgt{} state STOPPED (berr\PYGZhy{}counter tx 0 rx 0) restart\PYGZhy{}ms 100 
          bitrate 500000 sample\PYGZhy{}point 0.875
          tq 25 prop\PYGZhy{}seg 37 phase\PYGZhy{}seg1 32 phase\PYGZhy{}seg2 10 sjw 1 brp 1
          flexcan: tseg1 2..96 tseg2 2..32 sjw 1..16 brp 1..1024 brp\PYGZus{}inc 1
          dbitrate 2000000 dsample\PYGZhy{}point 0.750
          dtq 25 dprop\PYGZhy{}seg 7 dphase\PYGZhy{}seg1 7 dphase\PYGZhy{}seg2 5 dsjw 1 dbrp 1
          flexcan: dtseg1 2..39 dtseg2 2..8 dsjw 1..4 dbrp 1..1024 dbrp\PYGZus{}inc 1
          clock 40000000 
          re\PYGZhy{}started bus\PYGZhy{}errors arbit\PYGZhy{}lost error\PYGZhy{}warn error\PYGZhy{}pass bus\PYGZhy{}off
          0          0          0          0          0          0         numtxqueues 1 numrxqueues 1 gso\PYGZus{}max\PYGZus{}size 65536 gso\PYGZus{}max\PYGZus{}segs 65535 tso\PYGZus{}max\PYGZus{}size 65536 tso\PYGZus{}max\PYGZus{}segs 65535 gro\PYGZus{}max\PYGZus{}size 65536 parentbus platform parentdev 308c0000.can 
    RX:  bytes packets errors dropped  missed   mcast           
           281      31      0       0       0       0 
    TX:  bytes packets errors dropped carrier collsns           
           174      13      0       0       0       0
\end{sphinxVerbatim}

\sphinxAtStartPar
Set send queue length:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip link set dev can0 txqueuelen 100
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ip \PYGZhy{}details \PYGZhy{}statistics link show can0
4: can0: \PYGZlt{}NOARP,ECHO\PYGZgt{} mtu 72 qdisc pfifo\PYGZus{}fast state DOWN mode DEFAULT group default qlen 100                                              //Set the queue length to 100
    link/can  promiscuity 0  allmulti 0 minmtu 0 maxmtu 0 
    can \PYGZlt{}FD\PYGZgt{} state STOPPED (berr\PYGZhy{}counter tx 0 rx 0) restart\PYGZhy{}ms 100 
          bitrate 500000 sample\PYGZhy{}point 0.875
          tq 25 prop\PYGZhy{}seg 37 phase\PYGZhy{}seg1 32 phase\PYGZhy{}seg2 10 sjw 1 brp 1
          flexcan: tseg1 2..96 tseg2 2..32 sjw 1..16 brp 1..1024 brp\PYGZus{}inc 1
          dbitrate 2000000 dsample\PYGZhy{}point 0.750
          dtq 25 dprop\PYGZhy{}seg 7 dphase\PYGZhy{}seg1 7 dphase\PYGZhy{}seg2 5 dsjw 1 dbrp 1
          flexcan: dtseg1 2..39 dtseg2 2..8 dsjw 1..4 dbrp 1..1024 dbrp\PYGZus{}inc 1
          clock 40000000
          re\PYGZhy{}started bus\PYGZhy{}errors arbit\PYGZhy{}lost error\PYGZhy{}warn error\PYGZhy{}pass bus\PYGZhy{}off
          0          0          0          0          0          0         numtxqueues 1 numrxqueues 1 gso\PYGZus{}max\PYGZus{}size 65536 gso\PYGZus{}max\PYGZus{}segs 65535 tso\PYGZus{}max\PYGZus{}size 65536 tso\PYGZus{}max\PYGZus{}segs 65535 gro\PYGZus{}max\PYGZus{}size 65536 parentbus platform parentdev 308c0000.can 
    RX:  bytes packets errors dropped  missed   mcast           
           281      31      0       0       0       0
           TX:  bytes packets errors dropped carrier collsns           
           174      13      0       0       0       0
\end{sphinxVerbatim}


\section{4.22 SPI Test}
\label{\detokenize{linux-manual:spi-test}}
\sphinxAtStartPar
2 x SPI buses are led out form the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC carrier board, which are connected to flash w25q128fw.\\
The following are the read and write tests for the two flashes respectively.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Read qspi flash

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/urandom of=./test bs=100k count=1 conv=fsync oflag=direct
1+0 records in
1+0 records out
102400 bytes (102 kB, 100 KiB) copied, 0.003907 s, 26.2 MB/s
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=./test of=/dev/mtdblock0 bs=100k count=1 conv=fsync oflag=direct
1+0 records in
1+0 records out
102400 bytes (102 kB, 100 KiB) copied, 0.612079 s, 167 kB/s
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/mtdblock0 of=./test2 bs=100k count=1 conv=fsync iflag=direct 
1+0 records in
1+0 records out
102400 bytes (102 kB, 100 KiB) copied, 0.0080315 s, 12.7 MB/s
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} md5sum test test2
76910dd75b6a88bff3ac4a303815f939  test
76910dd75b6a88bff3ac4a303815f939  test2
\end{sphinxVerbatim}

\sphinxAtStartPar
The identical MD5 values indicate that the data written to the QSPI flash matches the data read out.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Read and write spi flash

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=./test of=/dev/mtdblock1 bs=100k count=1 conv=fsync oflag=direct
1+0 records in
1+0 records out
102400 bytes (102 kB, 100 KiB) copied, 0.874812 s, 117 kB/s
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} 
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=/dev/mtdblock1 of=./test3 bs=100k count=1 conv=fsync iflag=direct 
1+0 records in
1+0 records out
102400 bytes (102 kB, 100 KiB) copied, 0.0630821 s, 1.6 MB/s
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} 
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} md5sum test test3
76910dd75b6a88bff3ac4a303815f939  test
76910dd75b6a88bff3ac4a303815f939  test3
\end{sphinxVerbatim}

\sphinxAtStartPar
The MD5 values are the same, indicating that the data written into the SPI flash is consistent with the data read out.


\section{4.23 GPIO}
\label{\detokenize{linux-manual:gpio}}
\sphinxAtStartPar
The GPIO on the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC carrier board are extended via an I2C\sphinxhyphen{}to\sphinxhyphen{}GPIO chip.\\
The GPIO on P32 are extended through chip5, and the GPIO on P34 are extended through chip6.\\
\sphinxincludegraphics{{50646b9387fa4ef484fb9b269e0586d5}.png}\\
\sphinxincludegraphics{{9fbcc41185584f10b3d61017d64249f5}.png}\\
You can see both chips via a command.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gpiodetect 
gpiochip0 [30200000.gpio] (32 lines)
gpiochip1 [30210000.gpio] (32 lines)
gpiochip2 [30220000.gpio] (32 lines)
gpiochip3 [30230000.gpio] (32 lines)
gpiochip4 [30240000.gpio] (32 lines)
gpiochip5 [0\PYGZhy{}0023] (24 lines)
gpiochip6 [5\PYGZhy{}0022] (24 lines)
\end{sphinxVerbatim}

\sphinxAtStartPar
Use the gpioset command to set the output level (high or low) of a GPIO.\\
The command format is: gpioset \sphinxhyphen{}C chipindex < line = value >

\sphinxAtStartPar
The chipindex is set to the specific chip serial number, the line is set to the gpio serial number under the chip, and the value is set to the output level.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Set GPIO on chip 5\\
The pins are connected as follows:\sphinxincludegraphics{{a4a8701b93d348ce9b36a5ba5ef4d134}.png}Take the setting of GPIO7 as an example. GPIO7 is the GPIO20 \_ EXP on the SoM TCA6424IO expansion chip, and the chip is mounted on I2C1. So the corresponding chipindex is 5; the line is calculated as tens digit of the sequence number × 8 + units digit. For GPIO20\_EXP, the line is 2 × 8 + 0 = 16.\\
To set GPIO7 to output a high level:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gpioset \PYGZhy{}c 5 16=1
\end{sphinxVerbatim}

\sphinxAtStartPar
To set GPIO7 to output a low level:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gpioset \PYGZhy{}c 5 16=0
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Set gpio of chip6.

\end{enumerate}

\sphinxAtStartPar
Set GPIO P15 OUT as an example, chipindex = 6; line = 1 * 8 + 5 = 13.\\
To set GPIO P15 OUT to output a high level:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gpioset \PYGZhy{}c 6 13=1
\end{sphinxVerbatim}

\sphinxAtStartPar
To set GPIO P15 OUT to output a low level:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gpioset \PYGZhy{}c 6 13=0
\end{sphinxVerbatim}


\section{4.24 Sleep Wake\sphinxhyphen{}up Test}
\label{\detokenize{linux-manual:sleep-wake-up-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform supports sleep wake\sphinxhyphen{}up, currently supports serial wake\sphinxhyphen{}up, supports pwr key wake\sphinxhyphen{}up, and supports gpio wake\sphinxhyphen{}up\\
Enable serial port wake\sphinxhyphen{}up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo enabled \PYGZgt{} /sys/class/tty/ttymxc1/power/wakeup
\end{sphinxVerbatim}

\sphinxAtStartPar
Sleep:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} echo mem \PYGZgt{} /sys/power/state 
[12842.317424] PM: suspend entry (deep)
[12842.330144] Filesystems sync: 0.009 seconds
[12842.335039] Freezing user space processes
[12842.340999] Freezing user space processes completed (elapsed 0.001 seconds)
[12842.347997] OOM killer disabled.
[12842.351222] Freezing remaining freezable tasks
[12842.356944] Freezing remaining freezable tasks completed (elapsed 0.001 seconds)
[12842.364357] printk: Suspending console(s) (use no\PYGZus{}console\PYGZus{}suspend to debug)
\end{sphinxVerbatim}

\sphinxAtStartPar
Serial port input and enter to wake up:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[  903.218278] wlan: Received disassociation request on mlan0, reason: 3
[  903.218289] wlan: REASON: (Deauth) Sending STA is leaving (or has left) IBSS or ESS
[  903.243426] sd 0:0:0:0: [sda] Synchronizing SCSI cache
[  903.246522] None of the WOWLAN triggers enabled
[  903.246559] Suspend not allowed and retry again
......
[  907.149034] PM: resume devices took 3.372 seconds
[  907.345797] OOM killer enabled.
[  907.348945] Restarting tasks ... done.
[  907.355540] random: crng reseeded on system resumption
[  907.360827] PM: suspend exit
\end{sphinxVerbatim}

\sphinxAtStartPar
The system can also be woken up by a short press of the carrier board Power key or the K3 key.。


\section{4.25 IPv6 Test}
\label{\detokenize{linux-manual:ipv6-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform supports IPv6 on the Ethernet port. The test commands are as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} ping ipw.cn
PING ipw.cn(2408:8719:3000:a:41::18 (2408:8719:3000:a:41::18)) 56 data bytes
64 bytes from 2408:8719:3000:a:41::18 (2408:8719:3000:a:41::18): icmp\PYGZus{}seq=1 ttl=57 time=14.8 ms
64 bytes from 2408:8719:3000:a:41::18 (2408:8719:3000:a:41::18): icmp\PYGZus{}seq=2 ttl=57 time=16.0 ms
\end{sphinxVerbatim}


\chapter{5. Multimedia Test}
\label{\detokenize{linux-manual:multimedia-test}}
\sphinxAtStartPar
Some application layer software for audio and video on the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform uses Gstreamer, which supports hardware codecs. All examples in this section based on the GStreamer command line form. If users need a player with an interface, they can also use qt’s multimedia classes, which also support codecs, see the Qt Tests chapter.

\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform has an internal video processing unit, the VPU, which supports hard codecs for video in the following formats:\\
Video Decoding: H264, H265, VP8, VP9，maximum support 1080p 60fps\\
Video Encoding： H264, H265; maximum support 1080p 60fps.

\sphinxAtStartPar
Table of hardware codec parameters for the OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Video Decoder
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Format
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Profile
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Resolution
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Frame rate
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Bitrate
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar

&
\sphinxAtStartPar
HEVC
&
\sphinxAtStartPar
main/main 10
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
160Mbps
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
H.264
&
\sphinxAtStartPar
HP/MP/BP
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
60Mbps
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
VP9
&
\sphinxAtStartPar
Profile 0,2
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
100Mbps
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
VP8
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
60Mbps
\\
\sphinxhline
\sphinxAtStartPar
Video Encoder
&
\sphinxAtStartPar
H.264
&
\sphinxAtStartPar
HP/MP/BP
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
60Mbps
\\
\sphinxhline
\sphinxAtStartPar

&
\sphinxAtStartPar
H265
&
\sphinxAtStartPar
\sphinxhyphen{}
&
\sphinxAtStartPar
1920x1080
&
\sphinxAtStartPar
60 fps
&
\sphinxAtStartPar
60Mbps
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\section{5.1 Audio and Video Playback}
\label{\detokenize{linux-manual:audio-and-video-playback}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Use the Gplay player

\end{enumerate}

\sphinxAtStartPar
Gplay is an audio \sphinxhyphen{} video player implemented based on Gstreamer. It can automatically select appropriate plugins for audio \sphinxhyphen{} video playback according to the hardware. It is also very simple to run；

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}play\PYGZhy{}1.0 /home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Use gst \sphinxhyphen{} launch to play audio and video

\end{enumerate}

\sphinxAtStartPar
gst \sphinxhyphen{} launch is a commonly used debugging tool for developers during the development phase. Compared with Gplay, it is more flexible, but of course, it is also relatively more complicated to use.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/audio/30s.mp3 ! id3demux ! queue ! mpegaudioparse ! decodebin ! audioconvert ! audioresample ! pulsesink
\end{sphinxVerbatim}

\sphinxAtStartPar
Play video only:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux ! queue max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
Play audio and video simultaneously:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux name=demux demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec !  imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! decodebin ! audioconvert ! audioresample ! pulsesink
\end{sphinxVerbatim}


\section{5.2 Video Hardware Encoding}
\label{\detokenize{linux-manual:video-hardware-encoding}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports video encoding in H264, H265 formats up to 1080p 60fps.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
H.264 Hardware Encoding

\end{enumerate}

\sphinxAtStartPar
Encode the YUV420 format video into H264 format video, and use videotestsrc as the data source:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc num\PYGZhy{}buffers=300 ! \PYGZdq{}video/x\PYGZhy{}raw,format=YUY2,width=1920,height=1080,framerate=60/1\PYGZdq{} ! vpuenc\PYGZus{}h264 ! queue ! h264parse ! qtmux ! filesink location=yuv2h264.mp4
\end{sphinxVerbatim}

\sphinxAtStartPar
Play encoded H264 video:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}play\PYGZhy{}1.0 yuv2h264.mp4 
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see the video playing on the screen.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
H.265 Hardware Encoding

\end{enumerate}

\sphinxAtStartPar
Encode YUV420 video to H.265 format video:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc num\PYGZhy{}buffers=300 ! \PYGZdq{}video/x\PYGZhy{}raw,format=YUY2,width=1920,height=1080,framerate=60/1\PYGZdq{} ! vpuenc\PYGZus{}hevc ! queue ! h265parse ! qtmux ! filesink location=yuv2h265.mp4
\end{sphinxVerbatim}

\sphinxAtStartPar
Play encoded H265 video:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=yuv2h265.mp4 ! qtdemux ! queue ! vpudec ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see the video playing on the screen.


\section{5.3 Video Hardware Decoding}
\label{\detokenize{linux-manual:video-hardware-decoding}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports H264, H265, VP8, VP9 video hard decoding up to 1080p 60fps.\\
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC uses the vpudec component for video hard decoding. Its output formats are: NV12, I420, YV12.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
H264 Decoding

\end{enumerate}

\sphinxAtStartPar
Decode and play H264 video files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux ! queue max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
Decode and play H264 video files with audio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux name=demux demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! decodebin ! audioconvert ! audioresample ! pulsesink
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
H265 Decoding

\end{enumerate}

\sphinxAtStartPar
Decode and play H265 video files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}30fps\PYGZus{}h265\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux ! queue max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
Decode and play H265 video files with audio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}30fps\PYGZus{}h265\PYGZhy{}30S.mp4 typefind=true ! video/quicktime ! aiurdemux name=demux demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! decodebin ! audioconvert ! audioresample ! pulsesink
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
VP8 Decoding

\end{enumerate}

\sphinxAtStartPar
Decode and play VP8 video files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}vp8\PYGZhy{}30S.webm typefind=true ! video/x\PYGZhy{}matroska ! aiurdemux ! queue max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16,width=1024, height=600 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
Gst\sphinxhyphen{}launch\sphinxhyphen{}1.0 does not currently support playing OPUS audio.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
VP9 Decoding

\end{enumerate}

\sphinxAtStartPar
Decode and play VP9 video files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}30fps\PYGZus{}vp9.webm typefind=true ! video/x\PYGZhy{}matroska ! aiurdemux ! queue max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16,width=1024, height=600 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
Decode and play VP9 video files with audio:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}30fps\PYGZus{}vp9.webm typefind=true ! video/x\PYGZhy{}matroska ! aiurdemux name=demux demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16,width=1024, height=600 ! waylandsink demux. ! queue max\PYGZhy{}size\PYGZhy{}buffers=0 max\PYGZhy{}size\PYGZhy{}time=0 ! decodebin ! audioconvert ! audioresample ! pulsesink
\end{sphinxVerbatim}


\section{5.4 Video Conversion (Color Space Conversion and Rotation Scaling)}
\label{\detokenize{linux-manual:video-conversion-color-space-conversion-and-rotation-scaling}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC provides a video conversion component: imxvideoconvert\_g2d, which supports the following features:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Video color space conversion

\item {} 
\sphinxAtStartPar
Video scaling

\item {} 
\sphinxAtStartPar
Video Rotation

\end{itemize}

\sphinxAtStartPar
When performing video color space conversion, imxvideoconvert\_g2d only supports converting videos of other formats to RGB format.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Video color space conversion\\
Convert the built\sphinxhyphen{}in NV12 format video source of gstreamer to RGB16 format video:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc ! video/x\PYGZhy{}raw,format=NV12 ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw,format=RGB16 ! waylandsink
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
After decoding the h264 video, use imxvideoconvert \_ g2d to convert it to RGB16 video:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 filesrc location=/home/forlinx/video/1080p\PYGZus{}60fps\PYGZus{}h264\PYGZhy{}30S.mp4 ! qtdemux ! queue ! h264parse ! vpudec ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=1920, height=1080 ! waylandsink
\end{sphinxVerbatim}

\sphinxAtStartPar
The way of color space conversion after video decoding in other formats is the same, which is not repeated here.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Video scaling (adjust the resolution of the video) Convert the gstreamer’s own NV12 format 1280 * 720 video source to RGB16 format 640 * 480 video:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc ! video/x\PYGZhy{}raw,format=NV12,width=1280,height=720 ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, format=RGB16, width=640, height=480 ! waylandsink
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Video rotation

\end{enumerate}

\sphinxAtStartPar
Rotate the built\sphinxhyphen{}in video source of gstreamer by 90 degrees:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc ! imxvideoconvert\PYGZus{}g2d rotation=1 ! waylandsink
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Rotate the video source that comes with gstreamer by 180 degrees:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 videotestsrc ! imxvideoconvert\PYGZus{}g2d rotation=2 ! waylandsink
\end{sphinxVerbatim}


\section{5.5 Video Compositing}
\label{\detokenize{linux-manual:video-compositing}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC uses the imxcompositor \_ g2d component for video compositing. It uses hardware acceleration for video compositing. It can only output video in RGB format.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Combine two gstreamer’s own video sources into one:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 imxcompositor\PYGZus{}g2d name=comp sink\PYGZus{}1::xpos=160 sink\PYGZus{}1::ypos=480 ! glimagesink videotestsrc ! comp.sink\PYGZus{}0 videotestsrc ! comp.sink\PYGZus{}1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Combine two gstreamer’s own video sources into one, using a red background color:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 imxcompositor\PYGZus{}g2d background=0x000000FF name=comp sink\PYGZus{}1::xpos=160 sink\PYGZus{}1::ypos=480 ! glimagesink videotestsrc ! comp.sink\PYGZus{}0 videotestsrc ! comp.sink\PYGZus{}1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Combine two gstreamer’s own video sources into one, using CSC, resize, and rotate:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 imxcompositor\PYGZus{}g2d name=comp sink\PYGZus{}0::width=640 sink\PYGZus{}0::height=480 sink\PYGZus{}1::xpos=160 sink\PYGZus{}1::ypos=500 sink\PYGZus{}1::width=640 sink\PYGZus{}1::height=480 sink\PYGZus{}1::rotate=1 ! video/x\PYGZhy{}raw,format=RGB16 ! glimagesink videotestsrc ! video/x\PYGZhy{}raw,format=NV12,width=320,height=240 ! comp.sink\PYGZus{}0 videotestsrc ! video/x\PYGZhy{}raw,format=I420,width=320,height=240 ! comp.sink\PYGZus{}1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Combine three gstreamer native video sources into one, using CSC, resize, rotate, alpha, z\sphinxhyphen{}order, and maintaining the aspect ratio:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 imxcompositor\PYGZus{}g2d name=comp sink\PYGZus{}0::width=640 sink\PYGZus{}0::height=480 sink\PYGZus{}0::alpha=0.5 sink\PYGZus{}0::z\PYGZhy{}order=3 sink\PYGZus{}1::alpha=0.8 sink\PYGZus{}1::z\PYGZhy{}order=2 sink\PYGZus{}1::xpos=160 sink\PYGZus{}1::ypos=120 sink\PYGZus{}1::width=640 sink\PYGZus{}1::height=480 sink\PYGZus{}1::rotate=1 sink\PYGZus{}2::xpos=320 sink\PYGZus{}2::ypos=240 sink\PYGZus{}2::width=500 sink\PYGZus{}2::height=500 sink\PYGZus{}2::alpha=0.6 sink\PYGZus{}2::keep\PYGZhy{}ratio=true ! video/x\PYGZhy{}raw,format=RGB16 ! glimagesink videotestsrc ! video/x\PYGZhy{}raw,format=NV12,width=320,height=240 ! comp.sink\PYGZus{}0 videotestsrc ! video/x\PYGZhy{}raw,format=I420,width=320,height=240 ! comp.sink\PYGZus{}1 videotestsrc ! video/x\PYGZhy{}raw,format=RGB16,width=320,height=240 ! comp.sink\PYGZus{}2
\end{sphinxVerbatim}


\section{5.6 NPU Test}
\label{\detokenize{linux-manual:npu-test}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board is equipped with an iMX8MPLUS processor, which integrates an NPU with a computing power of up to 2.3 TOPS inside the CPU.

\sphinxAtStartPar
TensorFlow Lite testing\\
Demo recognizes information such as people, animals, plants, and places in the input image (grace\_copper. bp).

\sphinxAtStartPar
\sphinxincludegraphics{{d1763fc53fef4957957238a981b8f8d2}.png}\\
Run the demo on the CPU.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} cd /usr/bin/tensorflow\PYGZhy{}lite\PYGZhy{}2.11.1/examples/
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:/usr/bin/tensorflow\PYGZhy{}lite\PYGZhy{}2.11.1/examples\PYGZsh{} ./label\PYGZus{}image \PYGZhy{}m mobilenet\PYGZus{}v1\PYGZus{}1.0\PYGZus{}224\PYGZus{}quant.tflite \PYGZhy{}i grace\PYGZus{}hopper.bmp \PYGZhy{}l labels.txt
INFO: Loaded model mobilenet\PYGZus{}v1\PYGZus{}1.0\PYGZus{}224\PYGZus{}quant.tflite
INFO: resolved reporter
INFO: invoked
INFO: average time: 44.656 ms
INFO: 0.764706: 653 military uniform
INFO: 0.121569: 907 Windsor tie
INFO: 0.0156863: 458 bow tie
INFO: 0.0117647: 466 bulletproof vest
INFO: 0.00784314: 835 suit
\end{sphinxVerbatim}

\sphinxAtStartPar
NPU test demo

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:/usr/bin/tensorflow\PYGZhy{}lite\PYGZhy{}2.11.1/examples\PYGZsh{}./label\PYGZus{}image \PYGZhy{}m mobilenet\PYGZus{}v1\PYGZus{}1.0\PYGZus{}224\PYGZus{}quant.tflite  \PYGZhy{}l grace\PYGZus{}hopper.bmp  \PYGZhy{}l labels.txt 
\PYGZhy{}\PYGZhy{}external\PYGZus{}delegate\PYGZus{}path=/usr/lib/libvx\PYGZus{}delegate.so
INFO: Loaded model mobilenet\PYGZus{}v1\PYGZus{}1.0\PYGZus{}224\PYGZus{}quant.tflite
INFO: resolved reporter
Vx delegate: allowed\PYGZus{}cache\PYGZus{}mode set to 0.
Vx delegate: device num set to 0.
Vx delegate: allowed\PYGZus{}builtin\PYGZus{}code set to 0.
Vx delegate: error\PYGZus{}during\PYGZus{}init set to 0.
Vx delegate: error\PYGZus{}during\PYGZus{}prepare set to 0.
Vx delegate: error\PYGZus{}during\PYGZus{}invoke set to 0.
EXTERNAL delegate created.
INFO: Applied EXTERNAL delegate.
W [HandleLayoutInfer:291]Op 162: default layout inference pass.
INFO: invoked
INFO: average time: 2.801 ms
INFO: 0.768627: 653 military uniform
INFO: 0.105882: 907 Windsor tie
INFO: 0.0196078: 458 bow tie
INFO: 0.0117647: 466 bulletproof vest
INFO: 0.00784314: 835 suit
\end{sphinxVerbatim}

\sphinxAtStartPar
In both runs, the recognized classifications were military uniforms, Windsor ties, bow ties, and suits. When running on the CPU, the average time consumption was 44.656 ms. When running on the NPU, the average time consumption was 2.801 ms.


\section{5.7 Camera Test}
\label{\detokenize{linux-manual:id7}}
\sphinxAtStartPar
\sphinxstylestrong{Note: The OK \sphinxhyphen{} MX8MPQ \sphinxhyphen{} SMARC development board supports the installation of multiple cameras. When different cameras are installed, the serial numbers of the video nodes may vary. Please select the correct video node according to the actual situation.}


\subsection{5.7.1 USB Camera Test}
\label{\detokenize{linux-manual:usb-camera-test}}
\sphinxAtStartPar
Check whether the UVC Camera device node is identified, as shown in the following figure/dev/video4 node, and check the format and resolution supported by the camera:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}devices
 ():
        /dev/v4l\PYGZhy{}subdev0
        /dev/v4l\PYGZhy{}subdev1

 ():
        /dev/v4l\PYGZhy{}subdev2
        /dev/v4l\PYGZhy{}subdev3

VIV (platform:viv0):
        /dev/video2

VIV (platform:viv1):
        /dev/video3

vsi\PYGZus{}v4l2dec (platform:vsi\PYGZus{}v4l2dec):
        /dev/video1

vsi\PYGZus{}v4l2enc (platform:vsi\PYGZus{}v4l2enc):
        /dev/video0

viv\PYGZus{}media (platform:vvcam\PYGZhy{}video.0):
        /dev/media0

UVC Camera (046d:0825) (usb\PYGZhy{}xhci\PYGZhy{}hcd.1.auto\PYGZhy{}1.1):
        /dev/video4
        /dev/video5
        /dev/media1
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} 

root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}formats\PYGZhy{}ext \PYGZhy{}d /dev/video4
ioctl: VIDIOC\PYGZus{}ENUM\PYGZus{}FMT
        Type: Video Capture

        [0]: \PYGZsq{}YUYV\PYGZsq{} (YUYV 4:2:2)
                Size: Discrete 640x480
                        Interval: Discrete 0.033s (30.000 fps)
                        Interval: Discrete 0.040s (25.000 fps)
                        Interval: Discrete 0.050s (20.000 fps)
                        Interval: Discrete 0.067s (15.000 fps)
                        Interval: Discrete 0.100s (10.000 fps)
                        Interval: Discrete 0.200s (5.000 fps)
                Size: Discrete 160x120
                        Interval: Discrete 0.033s (30.000 fps)
                        Interval: Discrete 0.040s (25.000 fps)
                        Interval: Discrete 0.050s (20.000 fps)
                        Interval: Discrete 0.067s (15.000 fps)
                        Interval: Discrete 0.100s (10.000 fps)
                        Interval: Discrete 0.200s (5.000 fps)
                Size: Discrete 176x144
.....
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Camera preview:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video4 io\PYGZhy{}mode=2 ! video/x\PYGZhy{}raw, format=YUY2, width=640, height=480,framerate=30/1 ! imxvideoconvert\PYGZus{}g2d ! queue ! video/x\PYGZhy{}raw, format=RGB16, width=640, height=480 ! waylandsink
[  608.974755] enter isp\PYGZus{}mi\PYGZus{}stop
[  609.010524] enter isp\PYGZus{}mi\PYGZus{}stop
[  609.250587] usb 3\PYGZhy{}1.1: reset high\PYGZhy{}speed USB device number 3 using xhci\PYGZhy{}hcd
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
Redistribute latency...
\PYGZca{}Chandling interrupt.
Interrupt: Stopping pipeline ...
Execution ended after 0:00:06.775960375
Setting pipeline to NULL ...
Total showed frames (141), playing for (0:00:06.775873375), fps (20.809).
Freeing pipeline ...
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see a preview of the camera on the screen. Press CTRL + C at the terminal to stop the preview.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Camera to Take Pictures

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video4 io\PYGZhy{}mode=2 num\PYGZhy{}buffers=1 ! video/x\PYGZhy{}raw,format=YUY2,width=640,height=480,framerate=30/1 ! jpegenc ! filesink location=usb.jpeg
[  512.810753] enter isp\PYGZus{}mi\PYGZus{}stop
[  512.842836] enter isp\PYGZus{}mi\PYGZus{}stop
[  513.090557] usb 3\PYGZhy{}1.1: reset high\PYGZhy{}speed USB device number 3 using xhci\PYGZhy{}hcd
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.
Execution ended after 0:00:02.380040000
Setting pipeline to NULL ...
Freeing pipeline ...
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
After running it, it will generate usb.jpeg in the current directory. You can use the following commands to play:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}play\PYGZhy{}1.0 usb.jpeg \PYGZhy{}\PYGZhy{}wait\PYGZhy{}on\PYGZhy{}eos
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Camera recording:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video4 io\PYGZhy{}mode=2 num\PYGZhy{}buffers=300 ! video/x\PYGZhy{}raw, format=YUY2, width=640, height=480,framerate=30/1 ! imxvideoconvert\PYGZus{}g2d ! tee name=t ! queue ! vpuenc\PYGZus{}hevc ! queue ! h265parse ! qtmux ! filesink location=usb.mp4 t. ! queue ! waylandsink
Setting pipeline to PAUSED ...
====== VPUENC: 4.8.1 build on Aug  4 2023 01:42:29. ======
        wrapper: 3.0.0 (VPUWRAPPER\PYGZus{}ARM64\PYGZus{}LINUX Build on Aug 30 2023 01:43:48)
        vpulib: 1.1.1
        firmware: 1.1.1.43690
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
Redistribute latency...
Redistribute latency...
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.
Execution ended after 0:00:12.136800375
Setting pipeline to NULL ...
Total showed frames (300), playing for (0:00:12.136757875), fps (24.718).
Freeing pipeline ...
\end{sphinxVerbatim}

\sphinxAtStartPar
After using the above command, turn on the camera preview and recording. After recording 300 frames, stop recording, and the file usb.mp4 will be generated in the current directory.


\subsection{5.7.2 OV5645 Test}
\label{\detokenize{linux-manual:ov5645-test}}
\sphinxAtStartPar
Check whether the OV5645 device node is identified, as shown in the following figure/dev/video2 node, and check the format and resolution supported by the camera:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}devices
 ():
        /dev/v4l\PYGZhy{}subdev0
        /dev/v4l\PYGZhy{}subdev3
        /dev/v4l\PYGZhy{}subdev4

 ():
        /dev/v4l\PYGZhy{}subdev1
        /dev/v4l\PYGZhy{}subdev5
        /dev/v4l\PYGZhy{}subdev6

FSL Capture Media Device (platform:32c00000.bus:camera):
        /dev/media0

mxc\PYGZhy{}isi\PYGZhy{}cap (platform:32e00000.isi:cap\PYGZus{}devic):
        /dev/video2

VIV (platform:viv0):
        /dev/video3

VIV (platform:viv1):
        /dev/video4

vsi\PYGZus{}v4l2dec (platform:vsi\PYGZus{}v4l2dec):
        /dev/video1

vsi\PYGZus{}v4l2enc (platform:vsi\PYGZus{}v4l2enc):
        /dev/video0

viv\PYGZus{}media (platform:vvcam\PYGZhy{}video.0):
        /dev/media1
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} 
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}formats\PYGZhy{}ext \PYGZhy{}d /dev/video2
ioctl: VIDIOC\PYGZus{}ENUM\PYGZus{}FMT
        Type: Video Capture Multiplanar

        [0]: \PYGZsq{}RGBP\PYGZsq{} (16\PYGZhy{}bit RGB 5\PYGZhy{}6\PYGZhy{}5)
                Size: Discrete 1280x960
                Size: Discrete 1920x1080
                Size: Discrete 2592x1944
[1]: \PYGZsq{}RGB3\PYGZsq{} (24\PYGZhy{}bit RGB 8\PYGZhy{}8\PYGZhy{}8)
                Size: Discrete 1280x960
                Size: Discrete 1920x1080
                Size: Discrete 2592x1944
        [2]: \PYGZsq{}BGR3\PYGZsq{} (24\PYGZhy{}bit BGR 8\PYGZhy{}8\PYGZhy{}8)
                Size: Discrete 1280x960
                Size: Discrete 1920x1080
                Size: Discrete 2592x1944
        [3]: \PYGZsq{}YUYV\PYGZsq{} (YUYV 4:2:2)
                Size: Discrete 1280x960
                Size: Discrete 1920x1080
                Size: Discrete 2592x1944
        [4]: \PYGZsq{}YUV4\PYGZsq{} (32\PYGZhy{}bit A/XYUV 8\PYGZhy{}8\PYGZhy{}8\PYGZhy{}8)
                Size: Discrete 1280x960
                Size: Discrete 1920x1080
                Size: Discrete 2592x1944
.....
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Camera preview:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video2 io\PYGZhy{}mode=4 ! video/x\PYGZhy{}raw, format=YUY2, width=1280, height=960,framerate=30/1 ! imxvideoconvert\PYGZus{}g2d ! queue ! video/x\PYGZhy{}raw, format=RGB16, width=1024, height=600 ! waylandsink
[  888.282312] enter isp\PYGZus{}mi\PYGZus{}stop
[  888.314419] enter isp\PYGZus{}mi\PYGZus{}stop
[  888.382960] mxc\PYGZhy{}mipi\PYGZhy{}csi2.1: mipi\PYGZus{}csis\PYGZus{}imx8mp\PYGZus{}phy\PYGZus{}reset, No remote pad found!
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[  889.142655] bypass csc
[  889.145029] input fmt YUV4
[  889.147811] output fmt YUYV
Redistribute latency...
0:00:01.8 / 99:99:99.
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see a preview of the camera on the screen. Press CTRL + C at the terminal to stop the preview.\\
Note: Using the OV5645 to shoot a light source may cause abnormal automatic white balance and make the picture appear greenish. If there is a need, please contact Forlinx or modify the ISP parameters of the OV5645 by yourself.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Camera to Take Pictures

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video2 io\PYGZhy{}mode=4 num\PYGZhy{}buffers=10 ! video/x\PYGZhy{}raw,format=YUY2,width=1280,height=960,framerate=30/1 ! jpegenc ! filesink location=5645.jpeg
[ 1120.986895] enter isp\PYGZus{}mi\PYGZus{}stop
[ 1121.018716] enter isp\PYGZus{}mi\PYGZus{}stop
[ 1121.086983] mxc\PYGZhy{}mipi\PYGZhy{}csi2.1: mipi\PYGZus{}csis\PYGZus{}imx8mp\PYGZus{}phy\PYGZus{}reset, No remote pad found!
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[ 1121.605557] bypass csc
[ 1121.607943] input fmt YUV4
[ 1121.610721] output fmt YUYV
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.
Execution ended after 0:00:03.473213875
Setting pipeline to NULL ...
Freeing pipeline ...
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
After running, a file named 5645.jpeg will be generated in the current directory.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}play\PYGZhy{}1.0 5645.jpeg \PYGZhy{}\PYGZhy{}wait\PYGZhy{}on\PYGZhy{}eos
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Camera recording:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video2 io\PYGZhy{}mode=4 num\PYGZhy{}buffers=300 ! video/x\PYGZhy{}raw, format=YUY2, width=1280, height=960,framerate=30/1 ! imxvideoconvert\PYGZus{}g2d ! tee name=t ! queue ! vpuenc\PYGZus{}hevc ! queue ! h265parse ! qtmux ! filesink location=5645.mp4 t. ! queue ! waylandsink
[66149.712587] enter isp\PYGZus{}mi\PYGZus{}stop
[66149.779959] mxc\PYGZhy{}mipi\PYGZhy{}csi2.0: mipi\PYGZus{}csis\PYGZus{}imx8mp\PYGZus{}phy\PYGZus{}reset, No remote pad found!
[66149.958241] usb 3\PYGZhy{}1.4: reset high\PYGZhy{}speed USB device number 4 using xhci\PYGZhy{}hcd
Setting pipeline to PAUSED ...
====== VPUENC: 4.8.1 build on Aug  4 2023 01:42:29. ======
        wrapper: 3.0.0 (VPUWRAPPER\PYGZus{}ARM64\PYGZus{}LINUX Build on Aug 30 2023 01:43:48)
        vpulib: 1.1.1
        firmware: 1.1.1.43690
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[66150.940636] bypass csc
[66150.943011] input fmt YUV4
[66150.945737] output fmt YUYV
Redistribute latency...
Redistribute latency...
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.
Execution ended after 0:00:10.601885000
Setting pipeline to NULL ...
Total showed frames (301), playing for (0:00:10.601830625), fps (28.391).
Freeing pipeline ...
\end{sphinxVerbatim}

\sphinxAtStartPar
After using the above command, turn on the camera preview and recording. After recording 300 frames, stop recording, and the file 5645.mp4 will be generated in the current directory.


\subsection{5.7.3 BASLER CAMERA Test}
\label{\detokenize{linux-manual:basler-camera-test}}
\sphinxAtStartPar
Forlinx has adapted a BASLER CAMERA on the MIPI CSI1 of the carrier board. It is a MIPI camera without an ISP.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Check if the BASLER device node is recognized; check the formats and resolutions supported by the camera.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}devices
[  101.475839] enter isp\PYGZus{}mi\PYGZus{}stop
 ():
        /dev/v4l\PYGZhy{}subdev0
        /dev/v4l\PYGZhy{}subdev4
        /dev/v4l\PYGZhy{}subdev5

 ():
        /dev/v4l\PYGZhy{}subdev1

 (csi0):
        /dev/v4l\PYGZhy{}subdev2

FSL Capture Media Device (platform:32c00000.bus:camera):
        /dev/media0

mxc\PYGZhy{}isi\PYGZhy{}cap (platform:32e02000.isi:cap\PYGZus{}devic):
        /dev/video2

VIV (platform:viv0):
        /dev/video3

vsi\PYGZus{}v4l2dec (platform:vsi\PYGZus{}v4l2dec):
        /dev/video1

vsi\PYGZus{}v4l2enc (platform:vsi\PYGZus{}v4l2enc):
        /dev/video0

viv\PYGZus{}media (platform:vvcam\PYGZhy{}video.0):
        /dev/media1
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} 
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} v4l2\PYGZhy{}ctl \PYGZhy{}\PYGZhy{}list\PYGZhy{}formats\PYGZhy{}ext \PYGZhy{}d /dev/video3
ioctl: VIDIOC\PYGZus{}ENUM\PYGZus{}FMT
        Type: Video Capture

        [0]: \PYGZsq{}YUYV\PYGZsq{} (YUYV 4:2:2)
                Size: Stepwise 176x144 \PYGZhy{} 4096x3072 with step 16/8
        [1]: \PYGZsq{}NV12\PYGZsq{} (Y/UV 4:2:0)
                Size: Stepwise 176x144 \PYGZhy{} 4096x3072 with step 16/8
        [2]: \PYGZsq{}NV16\PYGZsq{} (Y/UV 4:2:2)
                Size: Stepwise 176x144 \PYGZhy{} 4096x3072 with step 16/8
        [3]: \PYGZsq{}BA12\PYGZsq{} (12\PYGZhy{}bit Bayer GRGR/BGBG)
                Size: Stepwise 176x144 \PYGZhy{} 4096x3072 with step 16/8
.....
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Camera preview:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video3 ! waylandsink
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[   81.090388] enter isp\PYGZus{}mi\PYGZus{}stop
[   81.871383] enter isp\PYGZus{}s\PYGZus{}comp
[   81.874287] enter isp\PYGZus{}s\PYGZus{}comp
[   81.877193] enter isp\PYGZus{}s\PYGZus{}comp
[   81.895727] enter wdr3\PYGZus{}hw\PYGZus{}init
[   81.898794] wdr3 res: 3840 2160 
[   81.976426] enter isp\PYGZus{}set\PYGZus{}stream 1
[   81.996258] enter isp\PYGZus{}mi\PYGZus{}start
Redistribute latency...
\PYGZca{}Chandling interrupt.
Interrupt: Stopping pipeline [   82.864815] enter isp\PYGZus{}set\PYGZus{}stream 0
...
Execution ended after 0:00:02.042127875
Setting pipeline to NULL ...
Total showed frames (22), playing for (0:00:02.042045875), fps (10.774).
[   82.896490] enter isp\PYGZus{}mi\PYGZus{}stop
[   83.088542] enter isp\PYGZus{}mi\PYGZus{}stop
Freeing pipeline ...
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see a preview of the camera on the screen. Press CTRL + C at the terminal to stop the preview.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
\sphinxAtStartPar
Camera to Take Pictures

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video3 io\PYGZhy{}mode=4 num\PYGZhy{}buffers=10 ! video/x\PYGZhy{}raw,format=YUY2,width=4096,height=3072,framerate=30/1 ! jpegenc ! filesink location=pic.jpeg
[  101.511726] enter isp\PYGZus{}mi\PYGZus{}stop
Setting pipeline to PAUSED ...
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[  101.987998] enter isp\PYGZus{}mi\PYGZus{}stop
[  102.509139] enter isp\PYGZus{}s\PYGZus{}comp
[  102.512058] enter isp\PYGZus{}s\PYGZus{}comp
[  102.514942] enter isp\PYGZus{}s\PYGZus{}comp
[  102.531964] enter wdr3\PYGZus{}hw\PYGZus{}init
[  102.535032] wdr3 res: 3840 2160 
[  102.601141] enter isp\PYGZus{}set\PYGZus{}stream 1
[  102.620656] enter isp\PYGZus{}mi\PYGZus{}start
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.[  133.044545] enter isp\PYGZus{}set\PYGZus{}stream 0

Execution ended after 0:00:31.424440000
Setting pipeline to NULL ...
[  133.075339] enter isp\PYGZus{}mi\PYGZus{}stop
[  133.284930] enter isp\PYGZus{}mi\PYGZus{}stop
Freeing pipeline ...
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{}
\end{sphinxVerbatim}

\sphinxAtStartPar
After running, a pic. jpeg will be generated in the current directory.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
\sphinxAtStartPar
Camera recording:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} gst\PYGZhy{}launch\PYGZhy{}1.0 v4l2src device=/dev/video3 io\PYGZhy{}mode=4 num\PYGZhy{}buffers=300 ! video/x\PYGZhy{}raw, format=YUY2, width=4096, height=3072, framerate=30/1 ! imxvideoconvert\PYGZus{}g2d ! video/x\PYGZhy{}raw, width=1920, height=1080 ! tee name=t ! queue ! vpuenc\PYGZus{}hevc ! queue ! h265parse ! qtmux ! filesink location=basler.mp4 t. ! queue ! waylandsink
[ 2236.675847] enter isp\PYGZus{}mi\PYGZus{}stop
Setting pipeline to PAUSED ...  
====== VPUENC: 4.8.1 build on Aug  4 2023 01:42:29. ======
        wrapper: 3.0.0 (VPUWRAPPER\PYGZus{}ARM64\PYGZus{}LINUX Build on Aug 30 2023 01:43:48)
        vpulib: 1.1.1
        firmware: 1.1.1.43690
Pipeline is live and does not need PREROLL ...
Pipeline is PREROLLED ...
Setting pipeline to PLAYING ...
New clock: GstSystemClock
[ 2237.293609] enter isp\PYGZus{}mi\PYGZus{}stop
[ 2237.837093] enter isp\PYGZus{}s\PYGZus{}comp
[ 2237.840036] enter isp\PYGZus{}s\PYGZus{}comp
[ 2237.842921] enter isp\PYGZus{}s\PYGZus{}comp
[ 2237.859662] enter wdr3\PYGZus{}hw\PYGZus{}init
[ 2237.862729] wdr3 res: 3840 2160 
[ 2237.939575] enter isp\PYGZus{}set\PYGZus{}stream 1
[ 2237.958881] enter isp\PYGZus{}mi\PYGZus{}start
Redistribute latency...
Redistribute latency...
Redistribute latency...
Got EOS from element \PYGZdq{}pipeline0\PYGZdq{}.
Execution ended after 0:00:11.805224875
Setting pipeline to[ 2248.745429] enter isp\PYGZus{}set\PYGZus{}stream 0
 NULL ...
Total showed frames (301), playing for (0:00:11.805166125), fps (25.497).
[ 2248.776180] enter isp\PYGZus{}mi\PYGZus{}stop
[ 2248.968523] enter isp\PYGZus{}mi\PYGZus{}stop
Freeing pipeline ...
\end{sphinxVerbatim}

\sphinxAtStartPar
After using the above command, turn on the camera preview and recording. After recording 300 frames, stop recording, and the file basler.mp4 will be generated in the current directory. Because the encoder only supports 1080p, the imxvideoconvert \_ g2d plugin was used for image scaling.


\chapter{6. System Settings}
\label{\detokenize{linux-manual:system-settings}}

\section{6.1 Updating Logo}
\label{\detokenize{linux-manual:updating-logo}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC platform has two types of logo displays: U\sphinxhyphen{}Boot display and Weston display.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The logo under uboot displays:\\
Currently, uboot supports mipi display and LVDS display, but does not support HDMI display. The method to replace the logo displayed under uboot is as follows: replace the picture in/run/media/Boot\sphinxhyphen{}mmcblk2p1 after the development board is started, and replace the MIPI screen with 1024x600 resolution

\end{enumerate}

\sphinxAtStartPar
​      Logo\sphinxhyphen{}1024x600.bmp, LVDS screen 1280x800 resolution replaces logo\sphinxhyphen{}1280 x800.bmp.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Weston’s logo shows:\\
The principle of Weston’s logo display is to replace the background of Weston with the logo image, modify the weston configuration file /etc/xdg/weston/weston.ini, replace background\sphinxhyphen{}image=/home/forlinx/logo/logo\sphinxhyphen{}1920x1080.png with the user’s logo path.

\end{enumerate}


\section{6.2 Self\sphinxhyphen{}starting Program Settings}
\label{\detokenize{linux-manual:self-starting-program-settings}}
\sphinxAtStartPar
Forlinx has preset the boot script/etc/autorun. sh through systemd, and this script will run automatically after booting. Users can modify this script to implement the application boot self\sphinxhyphen{}start function.\\
Users can also set up a new systemd service to realize the automatic startup function of the application.


\section{6.3 EEPROM Test}
\label{\detokenize{linux-manual:eeprom-test}}
\sphinxAtStartPar
The FET\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC SoM integrates an EEPROM with a capacity of 32KB. The space allocation in the EEPROM is shown in the following table:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Initial Address
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Size
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Content
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0x0
&
\sphinxAtStartPar
0x80
&
\sphinxAtStartPar
Header
\\
\sphinxhline
\sphinxAtStartPar
0x80
&
\sphinxAtStartPar
0x380
&
\sphinxAtStartPar
Board Config
\\
\sphinxhline
\sphinxAtStartPar
0x400
&
\sphinxAtStartPar
0x5000
&
\sphinxAtStartPar
DDR Param
\\
\sphinxhline
\sphinxAtStartPar
0x5400
&
\sphinxAtStartPar
0x400
&
\sphinxAtStartPar
Forlinx Reserved
\\
\sphinxhline
\sphinxAtStartPar
0x5800
&
\sphinxAtStartPar
0x2800
&
\sphinxAtStartPar
UserData
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{Note: Please do not modify the data offset before 0x5800 in EEPROM, or it may cause the failure of uboot startup.}

\sphinxAtStartPar
Board Config stores the mac addresses of the two network ports, and the default mac address is calculated based on the CPUID.   In the EEPROM, 10KB space is reserved for the user, and the user can read and write the data in the UserData through the eep \_ getuserdata () and the eep \_ setuserdata (). There are examples in the okmx8mp \_ smarc. c file.


\section{6.4 Starting the Watchdog Under Uboot}
\label{\detokenize{linux-manual:starting-the-watchdog-under-uboot}}
\sphinxAtStartPar
UBoot environment supports watchdog function. By default, the watchdog is not enabled. It can be activated by setting the following environment variables to initiate the watchdog’s default startup. Alternatively, the watchdog’s default startup can also be configured by modifying the device tree or the code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
u\PYGZhy{}boot=\PYGZgt{} setenv wdt\PYGZus{}start 1
u\PYGZhy{}boot=\PYGZgt{} setenv wdt\PYGZus{}timeout 10
u\PYGZhy{}boot=\PYGZgt{} saveenv
Saving Environment to MMC... Writing to MMC(2)... OK
\end{sphinxVerbatim}

\sphinxAtStartPar
Afterward, restart the board and you can see the following print in the startup printout, indicating that the watchdog has started:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
WDT:   Started watchdog@30280000 with servicing every 1000ms (10s timeout)
\end{sphinxVerbatim}

\sphinxAtStartPar
After starting the watchdog, there is dog feeding under the uboot, so the watchdog reboot will not be triggered under uboot. After uboot starts the kernel, if the kernel does not reinitialize the watchdog or feed the watchdog, the watchdog will restart the system after 10 seconds.\\
The default device tree for OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC reinitializes the watchdog.


\section{6.5 Kernel and Device Tree Loading via Uboot}
\label{\detokenize{linux-manual:kernel-and-device-tree-loading-via-uboot}}
\sphinxAtStartPar
OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports data transfer via TFTP under uboot. Supports ethernet@30be0000 (GBE1 port on the baseboard) and ethernet@30bf0000 (GBE0 port on the baseboard). Please select the appropriate port according to the actual network cable connection.\\
A common application scenario is to load the kernel and device tree through TFTP. Please set up the TFTP server in advance. The reference command is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
u\PYGZhy{}boot=\PYGZgt{} setenv ethact ethernet@30be0000
u\PYGZhy{}boot=\PYGZgt{} setenv gatewayip 192.168.1.1
u\PYGZhy{}boot=\PYGZgt{} setenv ipaddr 192.168.1.166
u\PYGZhy{}boot=\PYGZgt{} setenv netmask 255.255.255.0
u\PYGZhy{}boot=\PYGZgt{} setenv serverip 192.168.1.165
u\PYGZhy{}boot=\PYGZgt{} ping 192.168.1.165
Using ethernet@30be0000 device
host 192.168.1.165 is alive
u\PYGZhy{}boot=\PYGZgt{} tftp \PYGZdl{}\PYGZob{}fdt\PYGZus{}addr\PYGZus{}r\PYGZcb{} ok\PYGZhy{}mx8mp\PYGZhy{}smarc\PYGZhy{}2gb.dtb
Using ethernet@30be0000 device
TFTP from server 192.168.1.165; our IP address is 192.168.1.166
Filename \PYGZsq{}ok\PYGZhy{}mx8mp\PYGZhy{}smarc\PYGZhy{}2gb.dtb\PYGZsq{}.
Load address: 0x43000000
Loading: \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
         5.6 MiB/s
done
Bytes transferred = 70367 (112df hex)
u\PYGZhy{}boot=\PYGZgt{} tftp \PYGZdl{}\PYGZob{}loadaddr\PYGZcb{} Image
Using ethernet@30be0000 device
TFTP from server 192.168.1.165; our IP address is 192.168.1.166
Filename \PYGZsq{}Image\PYGZsq{}.
Load address: 0x40400000
Loading: \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
......
        \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}
         8.3 MiB/s
done
Bytes transferred = 32674304 (1f29200 hex)
u\PYGZhy{}boot=\PYGZgt{} setenv bootargs console=ttymxc1,115200 root=/dev/mmcblk2p2 rootwait rw
u\PYGZhy{}boot=\PYGZgt{} booti \PYGZdl{}\PYGZob{}kernel\PYGZus{}addr\PYGZus{}r\PYGZcb{} \PYGZhy{} \PYGZdl{}\PYGZob{}fdt\PYGZus{}addr\PYGZus{}r\PYGZcb{}
\PYGZsh{}\PYGZsh{} Flattened Device Tree blob at 43000000
   Booting using the fdt blob at 0x43000000
Working FDT set to 43000000
   Using Device Tree in place at 0000000043000000, end 00000000430142de
Working FDT set to 43000000

Starting kernel ...
\end{sphinxVerbatim}


\section{6.6 Display Settings}
\label{\detokenize{linux-manual:display-settings}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8 MPQ\sphinxhyphen{}SMARC has 4 x display interfaces (DSI0, LVDS0, LVDS1, HDMI).\\
According to the SMARC protocol specification, DSI0 and LVDS0 share a set of channels and can only use one peripheral at a time. In order to fully verify the peripheral performance of the CPU, the OK\sphinxhyphen{}MX8 MPQ\sphinxhyphen{}SMARC development board separates the DSI0 signal from the LVDS0 signal through a Switch chip U18, which can be used to verify their respective peripherals.\\
At present, OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC can be multiplexed into DSI0 or LVDS0 display channels through LVDS0 \_ TX0 signal. On the SoM, switch between the two interfaces by modifying the resistor (see the hardware manual of the SoM for details). On the carrier board, switch between the two interfaces by using the S5 switch. Therefore, the display of OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC can be divided into two groups of modes.\\
mode1, DSI0, LVDS1 Different display on three screens.\\
mode2: LVDS0 and LVDS1 display together, HDMI display differently.\\
MIPIDSI0 is currently configured with a resolution of 1024x600 and supports a maximum resolution of 2560x1440.\\
Both LVDS0 and LVDS1 are currently configured at 1280x800 and support a maximum resolution of 1366x768.\\
The maximum resolution supported by HDMI is 3840x2160.


\subsection{6.6.1 Dual LVDS Display Configuration}
\label{\detokenize{linux-manual:dual-lvds-display-configuration}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC supports merging 2 x 4lanes LVDS displays into a single 8lanes dual\sphinxhyphen{}channel LVDS display, where the two channels output odd and even pixels respectively, with a maximum resolution of 1920×1080.\\
To enable dual\sphinxhyphen{}channel LVDS, you need to modify the fsl,duplicate\sphinxhyphen{}channel attribute in the device tree to fsl,dual\sphinxhyphen{}channel, and modify the panel\sphinxhyphen{}timing of lvds0\_panel to match the timing of the new screen. fsl,duplicate\sphinxhyphen{}channel is used to output the data from LVDS0 to LVDS1 simultaneously, to realise the dual\sphinxhyphen{}screen heterodyne display. Enabling the “fsl,dual\sphinxhyphen{}channel” property activates the SPLIT mode for LVDS, with LVDS0 and LVDS1 channels outputting the odd and even pixels of the same display image respectively.\\
There is a pre\sphinxhyphen{}configured device tree file in the kernel, named ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc\sphinxhyphen{}lvds8lanes.dts, available for reference.


\section{6.7 Separate Compilation of U\sphinxhyphen{}Boot and Kernel}
\label{\detokenize{linux-manual:separate-compilation-of-u-boot-and-kernel}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MP\sphinxhyphen{}SMARC uses Yocto for compilation by default, but U\sphinxhyphen{}Boot, the kernel, and other components can also be compiled separately.\\
Uboot ：\\
config：okmx8mp\sphinxhyphen{}smarc\_defconfig\\
Cross\sphinxhyphen{}compilation：aarch64\sphinxhyphen{}linux\sphinxhyphen{}gnu\sphinxhyphen{}gcc\\
Arch：arm

\sphinxAtStartPar
Kernel：\\
Config：ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc\_defconfig\\
Dts：ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc.dts、ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc\sphinxhyphen{}2gb.dts\\
Cross\sphinxhyphen{}compilation：aarch64\sphinxhyphen{}linux\sphinxhyphen{}gnu\sphinxhyphen{}gcc\\
Arch：arm64


\chapter{7. System Flashing}
\label{\detokenize{linux-manual:system-flashing}}
\sphinxAtStartPar
The OK\sphinxhyphen{}MX8MPQ\sphinxhyphen{}SMARC development board currently supports USB flashing via the UUU tool, and also supports flashing via a TF card. The appropriate flashing tool is provided in the user documentation.


\section{7.1 Image Required for Flashing}
\label{\detokenize{linux-manual:image-required-for-flashing}}
\sphinxAtStartPar
Image Path: 02\sphinxhyphen{}User Profile\textbackslash{}01\sphinxhyphen{}Software Profile\textbackslash{}03\sphinxhyphen{}Mirror \& Source Code\textbackslash{}01\sphinxhyphen{}Mirror File


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Image
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
ok\sphinxhyphen{}mx8mp\sphinxhyphen{}uboot.bin
&
\sphinxAtStartPar
uboot
\\
\sphinxhline
\sphinxAtStartPar
ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard.a*
&
\sphinxAtStartPar
The entire file system in eMMC, the file obtained after split.
\\
\sphinxhline
\sphinxAtStartPar
ramdisk.img.gz
&
\sphinxAtStartPar
Virtual file system for TF card flashing
\\
\sphinxhline
\sphinxAtStartPar
Image
&
\sphinxAtStartPar
Kernel image
\\
\sphinxhline
\sphinxAtStartPar
ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc.dtb
&
\sphinxAtStartPar
This is the device tree used for development boards equipped with 4GB DDR.
\\
\sphinxhline
\sphinxAtStartPar
ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc\sphinxhyphen{}2gb.dtb
&
\sphinxAtStartPar
This is the device tree used for development boards equipped with 2GB DDR.
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The files ok8mp \sphinxhyphen{} linux \sphinxhyphen{} fs.sdcard.a* are obtained after splitting ok8mp \sphinxhyphen{} linux \sphinxhyphen{} fs.sdcard. The purpose is to avoid bugs caused by some file systems not supporting overly large files. Combine ok8mp\sphinxhyphen{}linux\sphinxhyphen{} fs. sdcard. a * to get ok8mp\sphinxhyphen{}linux\sphinxhyphen{} fs. sdcard. ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard is the complete file system from the eMMC. Please note the distinction between ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard, which is the merged file, and ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard.a*, which are the split files.\\
The reference commands for merging ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs. sdcard. a * under Linux system are as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@5d90dd71f33a:\PYGZti{}\PYGZsh{} cat ok8mp\PYGZhy{}linux\PYGZhy{}fs.sdcard.a* \PYGZgt{} ok8mp\PYGZhy{}linux\PYGZhy{}fs.sdcard
\end{sphinxVerbatim}


\section{7.2 Flashing U\sphinxhyphen{}Boot via USB}
\label{\detokenize{linux-manual:flashing-u-boot-via-usb}}

\subsection{7.2.1 Flashing Uboot to eMMC.}
\label{\detokenize{linux-manual:flashing-uboot-to-emmc}}
\sphinxAtStartPar
Use a USB cable to connect the development board’s Micro\sphinxhyphen{}USB port to the PC. Switch the board’s DIP switch to USB Serial Download mode, then power on the board.\\
The PC side runs the cmd program with administrator privileges. In the cmd program, use uuu.exe to flash U\sphinxhyphen{}Boot to the eMMC. The command is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}work\PYGZbs{}8MP\PYGZus{}SMARC\PYGZbs{}image\PYGZgt{}uuu.exe \PYGZhy{}b emmc ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin
\end{sphinxVerbatim}

\sphinxAtStartPar
Flashing is completed as shown below:\\
\sphinxincludegraphics{{18137ab150f84950ba36ad576526deee}.png}The uboot is flashed to boot0 partition in emmc.


\subsection{7.2.2 Flashing Uboot to SD}
\label{\detokenize{linux-manual:flashing-uboot-to-sd}}
\sphinxAtStartPar
Use a USB cable to connect the development board’s Micro\sphinxhyphen{}USB port to the PC. Switch the board’s DIP switch to USB Serial Download mode, then power on the board.\\
The PC side runs the cmd program with administrator privileges. In the cmd program, use uuu.exe to flash U\sphinxhyphen{}Boot to the eMMC. The command is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}work\PYGZbs{}8MP\PYGZus{}SMARC\PYGZbs{}image\PYGZgt{}uuu.exe \PYGZhy{}b sd ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin
\end{sphinxVerbatim}

\sphinxAtStartPar
Flashing is completed as shown below:\\
\sphinxincludegraphics{{b653d90d15ee48d888c568e3e6612fbc}.png}The uboot is flashed to a 32KB offset on the SD card.


\subsection{7.2.3 Flashing Uboot to QSPIFLASH}
\label{\detokenize{linux-manual:flashing-uboot-to-qspiflash}}
\sphinxAtStartPar
Use a USB cable to connect the development board’s Micro\sphinxhyphen{}USB port to the PC. Switch the board’s DIP switch to USB Serial Download mode, then power on the board.\\
The PC side runs the cmd program with administrator privileges. In the cmd program, use uuu.exe to flash U\sphinxhyphen{}Boot to the eMMC. The command is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}work\PYGZbs{}8MP\PYGZus{}SMARC\PYGZbs{}image\PYGZgt{}uuu.exe \PYGZhy{}b qspi ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin
\end{sphinxVerbatim}

\sphinxAtStartPar
Flashing is completed as shown below:\\
\sphinxincludegraphics{{56f2b61ad2404e1c9facfd007f49b2de}.png}The U\sphinxhyphen{}Boot is flashed to the 4KB offset of the QSPI flash.


\section{7.3 Flashing the File System via USB}
\label{\detokenize{linux-manual:flashing-the-file-system-via-usb}}
\sphinxAtStartPar
Use a USB cable to connect the development board’s Micro\sphinxhyphen{}USB port to the PC. Switch the board’s DIP switch to USB Serial Download mode, then power on the board.\\
The PC side runs the cmd program with administrator privileges. In the cmd program, use uuu.exe to flash U\sphinxhyphen{}Boot and file system to the eMMC. The command is as follows:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
D:\PYGZbs{}work\PYGZbs{}8MP\PYGZus{}SMARC\PYGZbs{}image\PYGZgt{}uuu.exe \PYGZhy{}b emmc\PYGZus{}all ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin ok8mp\PYGZhy{}linux\PYGZhy{}fs.sdcard
\end{sphinxVerbatim}

\sphinxAtStartPar
Flashing is completed as shown below:\sphinxincludegraphics{{207cf91fd4e24debb1a6d6f334e540cc}.png}


\section{7.4 Flashing Uboot in File System}
\label{\detokenize{linux-manual:flashing-uboot-in-file-system}}
\sphinxAtStartPar
Currently, U\sphinxhyphen{}Boot can only be flashed to the SPI flash via the file system and does not support OTG flashing.


\subsection{7.4.1 Flashing Uboot to SPIFLASH}
\label{\detokenize{linux-manual:flashing-uboot-to-spiflash}}
\sphinxAtStartPar
Copy the U\sphinxhyphen{}Boot image to the /home/root/ directory of the development board. Then, execute the following command to flash the U\sphinxhyphen{}Boot image (ok\sphinxhyphen{}mx8mp\sphinxhyphen{}uboot.bin) to the SPI flash.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dmesg  | grep spi                         
[    1.455837] spi\PYGZhy{}nor spi0.0: w25q128fw (16384 Kbytes)
[    1.461007] 1 fixed\PYGZhy{}partitions partitions found on MTD device 30bb0000.spi
[    1.467899] Creating 1 MTD partitions on \PYGZdq{}30bb0000.spi\PYGZdq{}:
[    1.473221] 0x000000000000\PYGZhy{}0x000001000000 : \PYGZdq{}qspiflash\PYGZdq{}
[    3.245186] spi\PYGZhy{}nor spi1.0: w25q128fw (16384 Kbytes)
[    3.250336] 1 fixed\PYGZhy{}partitions partitions found on MTD device spi1.0
[    3.256699] Creating 1 MTD partitions on \PYGZdq{}spi1.0\PYGZdq{}:
[    3.261498] 0x000000000000\PYGZhy{}0x000001000000 : \PYGZdq{}spiflash\PYGZdq{}
root@ok\PYGZhy{}mx8mpq\PYGZhy{}smarc:\PYGZti{}\PYGZsh{} dd if=ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin of=/dev/mtdblock1
4225+1 records in
4225+1 records out
2163632 bytes (2.2 MB, 2.1 MiB) copied, 16.7952 s, 129 kB/s
\end{sphinxVerbatim}

\sphinxAtStartPar
The uboot is flashed to spiflash, and no offset.


\section{7.5 Flashing via TF Card}
\label{\detokenize{linux-manual:flashing-via-tf-card}}

\subsection{7.5.1 Making Flashing Card}
\label{\detokenize{linux-manual:making-flashing-card}}
\sphinxAtStartPar
Please use a TF card with a capacity of 16GB or above to make a flashing card.\\
Two steps are required to make a flashing card:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Re\sphinxhyphen{}partition the TF card, reserve enough space for uboot image and environment variables in front of the 0 partition, reserve enough space for flashing image in the 0th partition, and format the 0 partition into vfat format. For example, if the device node of the TF card is /dev/mmcblk1, the reference commands are as follows:\\
Clean up the partition table and possible environment variables.

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@5d90dd71f33a:dd if=/dev/zero of=/dev/mmcblk1 bs=1M count=100 conv=fsync
\end{sphinxVerbatim}

\sphinxAtStartPar
Replug the TF card and create a new partition table.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@5d90dd71f33a:fdisk /dev/mmcblk1 \PYGZlt{}\PYGZlt{} EOF
n
p
1
16384

w
EOF
\end{sphinxVerbatim}

\sphinxAtStartPar
Format the partition

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@5d90dd71f33a:mkfs.vfat \PYGZhy{}F 32 \PYGZhy{}n \PYGZdq{}boot\PYGZdq{} /dev/mmcblk1p1
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
Flash the U\sphinxhyphen{}Boot image to the position with an offset of 32KB on the TF card. For example, if the device node of the TF card is /dev/mmcblk1, the reference commands are as follows:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
root@5d90dd71f33a:dd if=ok\PYGZhy{}mx8mp\PYGZhy{}uboot.bin of=/dev/mmcblk1 bs=1K seek=32 conv=fsync
\end{sphinxVerbatim}

\sphinxAtStartPar
The flashing card is made and next you need to copy the image to the flashing card.


\subsection{7.5.2 Copying the Required Image to The Flashing Card}
\label{\detokenize{linux-manual:copying-the-required-image-to-the-flashing-card}}
\sphinxAtStartPar
Copy ok\sphinxhyphen{}mx8mp\sphinxhyphen{}uboot.bin, ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard.a*, Image, ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc\sphinxhyphen{}2gb.dtb, ok\sphinxhyphen{}mx8mp\sphinxhyphen{}smarc.dtb, ramdisk.img.gzto tf card.\\
\sphinxincludegraphics{{40726eb041904298822ba3fca9d50b3c}.png}ramdisk.img.gz is already packaged by Forlinx, with a built\sphinxhyphen{}in flash script update.sh, which will be executed by default during the file system initialisation process. Users can also make their own ramdsik through tools such as busybox.\\
Note: The kernel Image and dtb finally flashed into the eMMC are the ones packaged in ok8mp\sphinxhyphen{}linux\sphinxhyphen{}fs.sdcard.a. The kernel Image and dtb in the TF card are used for TF card flashing and booting. Users can also modify the flash script in ramdisk to copy the kernel Image and dtb from the tf card to the emmc after flashing the emmc.


\subsection{7.5.3 Flashing EMMC With TF Card}
\label{\detokenize{linux-manual:flashing-emmc-with-tf-card}}
\sphinxAtStartPar
Adjust the DIP switch on the development board to TF card boot mode, insert the flashing card, and then power on the development board.\\
Uboot will boot from the TF card, and if the ramdisk. img. gz is read successfully, select to boot the file system through the ramdisk. img. gz. It is written in uboot environment variable.\\
The update.sh script in the /etc directory is executed after the filesystem is booted, which is used for flashing the filesystem, and a successful flash printout is shown below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
update start...
......

Command (m for help): The partition table has been altered.
Calling ioctl() to re\PYGZhy{}read partition table
[  213.591198]  mmcblk2: p1 p2
[Done] 208s
Please remove SD CARD!!!, wait for reboot.
\end{sphinxVerbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}